---
phase: 22-metrics-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/Services/Metrics/SyncMetrics.swift
  - apps/ios/trendy/Services/Metrics/MetricsSubscriber.swift
  - apps/ios/trendy/Services/Sync/SyncEngine.swift
  - apps/ios/trendy/trendyApp.swift
autonomous: true

must_haves:
  truths:
    - "Sync operations visible in Instruments Time Profiler"
    - "Rate limit hits recorded as signpost events"
    - "Retry attempts recorded as signpost events"
    - "Circuit breaker trips recorded as signpost events"
    - "Success/failure recorded as signpost events"
    - "MetricKit subscriber receives daily payloads on physical device"
  artifacts:
    - path: "apps/ios/trendy/Services/Metrics/SyncMetrics.swift"
      provides: "OSSignposter + mxSignpost instrumentation"
      contains: "beginInterval"
      min_lines: 80
    - path: "apps/ios/trendy/Services/Metrics/MetricsSubscriber.swift"
      provides: "MXMetricManagerSubscriber implementation"
      contains: "didReceive"
      min_lines: 50
  key_links:
    - from: "SyncEngine.swift"
      to: "SyncMetrics.swift"
      via: "SyncMetrics.beginInterval/endInterval calls"
      pattern: "SyncMetrics\\.(begin|end|record)"
    - from: "trendyApp.swift"
      to: "MetricsSubscriber.swift"
      via: "MetricsSubscriber.shared initialization"
      pattern: "MetricsSubscriber\\.shared"
---

<objective>
Create production observability infrastructure for SyncEngine using Apple's native telemetry frameworks.

Purpose: Enable development profiling (Instruments) and production telemetry (MetricKit) for sync operations. This completes the v1.2 quality milestone by providing visibility into sync performance, rate limiting, and failure patterns.

Output:
- SyncMetrics.swift: Centralized signpost/metric collection
- MetricsSubscriber.swift: MXMetricManagerSubscriber singleton
- SyncEngine instrumented with interval tracking and event recording
</objective>

<execution_context>
@/Users/cipher/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cipher/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-metrics-documentation/22-RESEARCH.md
@apps/ios/trendy/Utilities/Logger.swift
@apps/ios/trendy/Services/Sync/SyncEngine.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncMetrics instrumentation class</name>
  <files>apps/ios/trendy/Services/Metrics/SyncMetrics.swift</files>
  <action>
Create SyncMetrics.swift in new Services/Metrics/ directory with:

1. **Signpost name constants** (enum SignpostName):
   - fullSync, flushMutations, pullChanges, bootstrapFetch, healthCheck

2. **MetricKit log handle**:
   - `static let logHandle = MXMetricManager.makeLogHandle(category: "SyncEngine")`

3. **OSSignposter** (tied to Log.sync):
   - `private static let signposter = OSSignposter(logger: Log.sync)`

4. **Interval tracking** with thread-safe storage:
   - `beginInterval(_ name: String) -> OSSignpostID` - starts both OSSignposter and mxSignpost
   - `endInterval(_ name: String, id: OSSignpostID)` - ends both
   - Use NSLock for thread safety on activeIntervals dictionary

5. **Event recording**:
   - `recordRateLimitHit()` - mxSignpost(.event) + signposter.emitEvent
   - `recordRetry()` - mxSignpost(.event) + signposter.emitEvent
   - `recordCircuitBreakerTrip()` - mxSignpost(.event) + signposter.emitEvent
   - `recordSyncSuccess()` - mxSignpost(.event) + signposter.emitEvent
   - `recordSyncFailure()` - mxSignpost(.event) + signposter.emitEvent

Key implementation detail from research:
- Use `mxSignpost` (not just OSSignposter) so events appear in both Instruments AND MetricKit production telemetry
- Use constants for signpost names (begin/end names MUST match exactly)
- Import `os` and `MetricKit`

Reference the pattern from 22-RESEARCH.md "Complete SyncMetrics Implementation" section.
  </action>
  <verify>File exists at apps/ios/trendy/Services/Metrics/SyncMetrics.swift with SignpostName enum, logHandle, signposter, beginInterval/endInterval methods, and event recording methods. Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build 2>&1 | tail -20`</verify>
  <done>SyncMetrics.swift provides centralized instrumentation for all sync operations with both development (OSSignposter) and production (mxSignpost) coverage</done>
</task>

<task type="auto">
  <name>Task 2: Create MetricsSubscriber for production telemetry</name>
  <files>apps/ios/trendy/Services/Metrics/MetricsSubscriber.swift</files>
  <action>
Create MetricsSubscriber.swift implementing MXMetricManagerSubscriber:

1. **Singleton pattern**:
   - `static let shared = MetricsSubscriber()`
   - Private init that calls `MXMetricManager.shared.add(self)`
   - deinit that calls `MXMetricManager.shared.remove(self)`

2. **didReceive(_ payloads: [MXMetricPayload])**:
   - Filter out `payload.includesMultipleApplicationVersions` (mixed-version data)
   - For each payload, call processPayload(_:)

3. **didReceive(_ payloads: [MXDiagnosticPayload])**:
   - Log crash diagnostic count (bonus, minimal implementation)

4. **processPayload(_:)**:
   - Log time range (timeStampEnd - timeStampBegin)
   - Log app version from metaData
   - Process signpostMetrics: for each metric, log category, name, totalCount
   - Use Log.sync for all logging

Key implementation detail from research:
- MetricKit only works on physical device (not Simulator)
- Payloads arrive "at most once per day"
- Filter by includesMultipleApplicationVersions to avoid mixed data

Reference the pattern from 22-RESEARCH.md "MetricsSubscriber Implementation" section.
  </action>
  <verify>File exists at apps/ios/trendy/Services/Metrics/MetricsSubscriber.swift implementing MXMetricManagerSubscriber with didReceive methods. Build succeeds.</verify>
  <done>MetricsSubscriber singleton receives and logs daily MetricKit payloads with signpost metrics for production telemetry</done>
</task>

<task type="auto">
  <name>Task 3: Instrument SyncEngine with metrics</name>
  <files>apps/ios/trendy/Services/Sync/SyncEngine.swift, apps/ios/trendy/trendyApp.swift</files>
  <action>
**SyncEngine.swift instrumentation:**

1. **performSync()** - wrap entire method:
   ```swift
   let syncId = SyncMetrics.beginInterval(SyncMetrics.SignpostName.fullSync)
   defer { SyncMetrics.endInterval(SyncMetrics.SignpostName.fullSync, id: syncId) }
   ```
   - Add `SyncMetrics.recordSyncSuccess()` before final `.idle` state
   - Add `SyncMetrics.recordSyncFailure()` in catch block

2. **flushPendingMutations()** - wrap entire method:
   ```swift
   let flushId = SyncMetrics.beginInterval(SyncMetrics.SignpostName.flushMutations)
   defer { SyncMetrics.endInterval(SyncMetrics.SignpostName.flushMutations, id: flushId) }
   ```

3. **pullChanges()** - wrap entire method:
   ```swift
   let pullId = SyncMetrics.beginInterval(SyncMetrics.SignpostName.pullChanges)
   defer { SyncMetrics.endInterval(SyncMetrics.SignpostName.pullChanges, id: pullId) }
   ```

4. **bootstrapFetch()** - wrap entire method:
   ```swift
   let bootstrapId = SyncMetrics.beginInterval(SyncMetrics.SignpostName.bootstrapFetch)
   defer { SyncMetrics.endInterval(SyncMetrics.SignpostName.bootstrapFetch, id: bootstrapId) }
   ```

5. **performHealthCheck()** - wrap entire method:
   ```swift
   let healthId = SyncMetrics.beginInterval(SyncMetrics.SignpostName.healthCheck)
   defer { SyncMetrics.endInterval(SyncMetrics.SignpostName.healthCheck, id: healthId) }
   ```

6. **Rate limit handling** - find existing rate limit code (look for 429 or rateLimitCircuitBreakerThreshold):
   - Add `SyncMetrics.recordRateLimitHit()` when rate limit detected
   - Add `SyncMetrics.recordCircuitBreakerTrip()` when circuit breaker trips (consecutiveRateLimitErrors >= threshold)

7. **Retry handling** - find retry loops:
   - Add `SyncMetrics.recordRetry()` on each retry attempt

**trendyApp.swift initialization:**

In the App init or early lifecycle, add:
```swift
// Initialize MetricKit subscriber for production telemetry
_ = MetricsSubscriber.shared
```

This ensures the subscriber is registered before any sync operations occur.
  </action>
  <verify>
1. SyncEngine.swift contains SyncMetrics calls for all 5 operations (fullSync, flushMutations, pullChanges, bootstrapFetch, healthCheck)
2. SyncEngine.swift contains recordRateLimitHit, recordCircuitBreakerTrip, recordRetry, recordSyncSuccess, recordSyncFailure calls
3. trendyApp.swift references MetricsSubscriber.shared
4. Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build 2>&1 | tail -20`
  </verify>
  <done>SyncEngine operations instrumented with signpost intervals and event recording; MetricsSubscriber initialized at app launch</done>
</task>

</tasks>

<verification>
1. All files compile: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build`
2. SyncMetrics.swift exists with beginInterval/endInterval and event recording
3. MetricsSubscriber.swift exists implementing MXMetricManagerSubscriber
4. SyncEngine.swift contains SyncMetrics instrumentation for all operations
5. trendyApp.swift initializes MetricsSubscriber.shared
</verification>

<success_criteria>
- METR-01: Sync duration tracked via SyncMetrics.beginInterval/endInterval for fullSync
- METR-02: Success/failure tracked via recordSyncSuccess/recordSyncFailure
- METR-03: Rate limit hits tracked via recordRateLimitHit
- METR-04: Retry patterns tracked via recordRetry
- METR-05: OSSignposter instrumentation viewable in Instruments
- METR-06: MetricKit subscriber processes daily payloads (testable on device)
</success_criteria>

<output>
After completion, create `.planning/phases/22-metrics-documentation/22-01-SUMMARY.md`
</output>
