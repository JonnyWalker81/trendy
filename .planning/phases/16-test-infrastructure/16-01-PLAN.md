---
phase: 16-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendyTests/Mocks/MockNetworkClient.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "MockNetworkClient can be injected into SyncEngine instead of real APIClient"
    - "Tests can verify which network methods were called and with what arguments"
    - "Tests can configure sequential responses for retry/circuit breaker testing"
    - "Mock is thread-safe for concurrent test execution"
  artifacts:
    - path: "apps/ios/trendyTests/Mocks/MockNetworkClient.swift"
      provides: "MockNetworkClient implementing NetworkClientProtocol"
      min_lines: 400
      exports: ["MockNetworkClient"]
  key_links:
    - from: "MockNetworkClient"
      to: "NetworkClientProtocol"
      via: "protocol conformance"
      pattern: "final class MockNetworkClient: NetworkClientProtocol"
---

<objective>
Create MockNetworkClient implementing NetworkClientProtocol with spy pattern for unit testing SyncEngine.

Purpose: Enable isolated unit testing of SyncEngine by replacing real network calls with configurable mock responses. The spy pattern allows tests to verify which methods were called and with what arguments.

Output: MockNetworkClient.swift in trendyTests/Mocks/ directory with full NetworkClientProtocol conformance, typed call records, and response queue support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-test-infrastructure/16-RESEARCH.md

# Protocol to implement
@apps/ios/trendy/Protocols/NetworkClientProtocol.swift

# API models for return types and request types
@apps/ios/trendy/Models/API/APIModels.swift

# Existing test patterns
@apps/ios/trendyTests/TestSupport.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MockNetworkClient with spy pattern and response configuration</name>
  <files>apps/ios/trendyTests/Mocks/MockNetworkClient.swift</files>
  <action>
Create a new file `apps/ios/trendyTests/Mocks/MockNetworkClient.swift` implementing NetworkClientProtocol.

**Structure:**

1. **Sendable and Thread Safety:**
   - Mark as `final class MockNetworkClient: NetworkClientProtocol, @unchecked Sendable`
   - Use `private let lock = NSLock()` for all mutable state access
   - Lock before reading/writing, unlock in defer blocks

2. **Call Recording (Spy Pattern):**
   Define typed call record structs for key methods (others can use a generic pattern):
   ```swift
   struct GetEventTypesCall { let timestamp: Date }
   struct CreateEventTypeCall { let request: CreateEventTypeRequest; let idempotencyKey: String?; let timestamp: Date }
   struct CreateEventCall { let request: CreateEventRequest; let idempotencyKey: String?; let timestamp: Date }
   struct CreateEventsBatchCall { let events: [CreateEventRequest]; let timestamp: Date }
   struct UpdateEventCall { let id: String; let request: UpdateEventRequest; let timestamp: Date }
   struct DeleteEventCall { let id: String; let timestamp: Date }
   struct GetChangesCall { let cursor: Int64; let limit: Int; let timestamp: Date }
   // Add similar for geofence, property definition operations
   ```

   Store in arrays: `private(set) var getEventTypesCalls: [GetEventTypesCall] = []`

3. **Response Configuration:**
   - Simple properties for default returns:
     ```swift
     var eventTypesToReturn: [APIEventType] = []
     var eventsToReturn: [APIEvent] = []
     var geofencesToReturn: [APIGeofence] = []
     var propertyDefinitionsToReturn: [APIPropertyDefinition] = []
     var changeFeedResponseToReturn: ChangeFeedResponse?
     var latestCursorToReturn: Int64 = 0
     var batchCreateResponseToReturn: BatchCreateEventsResponse?
     ```

   - Error injection: `var errorToThrow: Error?`

   - Response queues for sequential testing (critical for circuit breaker tests):
     ```swift
     var getEventTypesResponses: [Result<[APIEventType], Error>] = []
     var getEventsResponses: [Result<[APIEvent], Error>] = []
     var getChangesResponses: [Result<ChangeFeedResponse, Error>] = []
     // Add queues for other methods that need sequential testing
     ```

4. **Protocol Implementation Pattern:**
   For each method, follow this pattern:
   ```swift
   func getEventTypes() async throws -> [APIEventType] {
       lock.lock()
       getEventTypesCalls.append(GetEventTypesCall(timestamp: Date()))

       // Check response queue first (for sequential testing)
       if !getEventTypesResponses.isEmpty {
           let result = getEventTypesResponses.removeFirst()
           lock.unlock()
           switch result {
           case .success(let types): return types
           case .failure(let error): throw error
           }
       }
       lock.unlock()

       // Check global error
       if let error = errorToThrow {
           throw error
       }

       // Return configured response
       return eventTypesToReturn
   }
   ```

5. **Helper Methods:**
   ```swift
   func reset() {
       lock.lock()
       defer { lock.unlock() }
       // Clear all call arrays
       // Clear all response queues
       // Reset all return values to defaults
       // Clear errorToThrow
   }

   var totalCallCount: Int {
       lock.lock()
       defer { lock.unlock() }
       return getEventTypesCalls.count + createEventCalls.count + ...
   }
   ```

**All 24 NetworkClientProtocol methods must be implemented:**
- Event Type: getEventTypes, createEventType, createEventTypeWithIdempotency, updateEventType, deleteEventType
- Event: getEvents, getAllEvents, createEvent, createEventWithIdempotency, createEventsBatch, updateEvent, deleteEvent
- Geofence: getGeofences, createGeofence, createGeofenceWithIdempotency, updateGeofence, deleteGeofence
- Property Definition: getPropertyDefinitions, createPropertyDefinition, createPropertyDefinitionWithIdempotency, updatePropertyDefinition, deletePropertyDefinition
- Change Feed: getChanges, getLatestCursor

Import `@testable import trendy` and `import Foundation` at the top.
  </action>
  <verify>
Build the test target to verify MockNetworkClient compiles and conforms to NetworkClientProtocol:
```bash
cd apps/ios && xcodebuild build-for-testing -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(error:|MockNetworkClient|Build Succeeded)"
```
  </verify>
  <done>
MockNetworkClient exists in trendyTests/Mocks/, implements all 24 NetworkClientProtocol methods, has typed call records for key methods, supports response queuing for sequential behavior testing, and compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for MockNetworkClient behavior</name>
  <files>apps/ios/trendyTests/Mocks/MockNetworkClientTests.swift</files>
  <action>
Create `apps/ios/trendyTests/Mocks/MockNetworkClientTests.swift` with tests validating the mock's behavior.

Use Swift Testing framework (#expect, @Test) not XCTest.

**Tests to include:**

```swift
import Testing
@testable import trendy

@Test("MockNetworkClient tracks method calls")
func test_tracksMethodCalls() async throws {
    let mock = MockNetworkClient()
    mock.eventTypesToReturn = [APIModelFixture.makeAPIEventType()]

    _ = try await mock.getEventTypes()

    #expect(mock.getEventTypesCalls.count == 1)
    #expect(mock.getEventTypesCalls.first?.timestamp != nil)
}

@Test("MockNetworkClient returns configured response")
func test_returnsConfiguredResponse() async throws {
    let mock = MockNetworkClient()
    let expected = APIModelFixture.makeAPIEventType(id: "custom-id", name: "Custom")
    mock.eventTypesToReturn = [expected]

    let types = try await mock.getEventTypes()

    #expect(types.count == 1)
    #expect(types.first?.id == "custom-id")
    #expect(types.first?.name == "Custom")
}

@Test("MockNetworkClient throws configured error")
func test_throwsConfiguredError() async throws {
    let mock = MockNetworkClient()
    mock.errorToThrow = APIError.httpError(500)

    await #expect(throws: APIError.self) {
        try await mock.getEventTypes()
    }

    // Call was still recorded
    #expect(mock.getEventTypesCalls.count == 1)
}

@Test("MockNetworkClient response queue enables sequential testing")
func test_responseQueueSequentialBehavior() async throws {
    let mock = MockNetworkClient()
    mock.getEventTypesResponses = [
        .failure(APIError.httpError(500)),
        .failure(APIError.httpError(500)),
        .success([APIModelFixture.makeAPIEventType()])
    ]

    // First two calls throw
    await #expect(throws: APIError.self) {
        try await mock.getEventTypes()
    }
    await #expect(throws: APIError.self) {
        try await mock.getEventTypes()
    }

    // Third call succeeds
    let types = try await mock.getEventTypes()
    #expect(types.count == 1)

    // All three calls recorded
    #expect(mock.getEventTypesCalls.count == 3)
}

@Test("MockNetworkClient reset clears all state")
func test_resetClearsState() async throws {
    let mock = MockNetworkClient()
    mock.eventTypesToReturn = [APIModelFixture.makeAPIEventType()]
    mock.errorToThrow = APIError.httpError(500)
    _ = try? await mock.getEventTypes()

    mock.reset()

    #expect(mock.getEventTypesCalls.isEmpty)
    #expect(mock.eventTypesToReturn.isEmpty)
    #expect(mock.errorToThrow == nil)
}

@Test("MockNetworkClient records create call arguments")
func test_recordsCreateCallArguments() async throws {
    let mock = MockNetworkClient()
    mock.eventsToReturn = [APIModelFixture.makeAPIEvent()]

    let request = APIModelFixture.makeCreateEventRequest(
        eventTypeId: "type-123",
        notes: "Test notes"
    )
    _ = try await mock.createEvent(request)

    #expect(mock.createEventCalls.count == 1)
    #expect(mock.createEventCalls.first?.request.eventTypeId == "type-123")
    #expect(mock.createEventCalls.first?.request.notes == "Test notes")
}
```
  </action>
  <verify>
Run the mock tests:
```bash
cd apps/ios && xcodebuild test -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' -only-testing:trendyTests/MockNetworkClientTests CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(Test Case|passed|failed|error:)"
```
  </verify>
  <done>
MockNetworkClientTests.swift exists with 6+ tests covering call tracking, response configuration, error injection, response queue sequential behavior, reset functionality, and argument recording. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. MockNetworkClient.swift exists in apps/ios/trendyTests/Mocks/
2. MockNetworkClient implements all 24 NetworkClientProtocol methods
3. MockNetworkClient has typed call record structs for key methods
4. MockNetworkClient supports response queuing for sequential behavior testing
5. MockNetworkClient is thread-safe (@unchecked Sendable with NSLock)
6. MockNetworkClientTests.swift exists with passing tests
7. Test target builds successfully
</verification>

<success_criteria>
- MockNetworkClient conforms to NetworkClientProtocol (compiler verified)
- Tests can inject MockNetworkClient where NetworkClientProtocol is expected
- Spy pattern tracks all method calls with timestamps and arguments
- Response queue enables sequential behavior testing (fail, fail, succeed pattern)
- Thread safety via NSLock prevents data races in concurrent tests
- All mock tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-test-infrastructure/16-01-SUMMARY.md`
</output>
