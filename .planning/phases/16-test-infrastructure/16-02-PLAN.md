---
phase: 16-test-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendyTests/Mocks/MockDataStore.swift
  - apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift
  - apps/ios/trendyTests/TestSupport.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "MockDataStore provides in-memory state management for isolated testing"
    - "MockDataStoreFactory can be injected into SyncEngine instead of DefaultDataStoreFactory"
    - "Tests can verify which data store methods were called"
    - "Test fixtures exist for all API models needed by SyncEngine tests"
  artifacts:
    - path: "apps/ios/trendyTests/Mocks/MockDataStore.swift"
      provides: "MockDataStore implementing DataStoreProtocol"
      min_lines: 300
      exports: ["MockDataStore"]
    - path: "apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift"
      provides: "MockDataStoreFactory implementing DataStoreFactory"
      min_lines: 20
      exports: ["MockDataStoreFactory"]
    - path: "apps/ios/trendyTests/TestSupport.swift"
      provides: "Extended API model fixtures"
      contains: "makeChangeFeedResponse"
  key_links:
    - from: "MockDataStore"
      to: "DataStoreProtocol"
      via: "protocol conformance"
      pattern: "final class MockDataStore: DataStoreProtocol"
    - from: "MockDataStoreFactory"
      to: "DataStoreFactory"
      via: "protocol conformance"
      pattern: "final class MockDataStoreFactory: DataStoreFactory"
---

<objective>
Create MockDataStore and MockDataStoreFactory for testing SyncEngine data persistence, plus extend TestSupport.swift with fixtures for ChangeFeedResponse and other API models.

Purpose: Enable isolated unit testing of SyncEngine by replacing real SwiftData persistence with in-memory mock state. The factory pattern allows passing mocks across actor boundaries (factory is Sendable, store is not).

Output:
- MockDataStore.swift implementing DataStoreProtocol with in-memory dictionaries
- MockDataStoreFactory.swift implementing DataStoreFactory
- Extended TestSupport.swift with fixtures for ChangeFeedResponse, ChangeEntry, APIGeofence, APIPropertyDefinition
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-test-infrastructure/16-RESEARCH.md

# Protocols to implement
@apps/ios/trendy/Protocols/DataStoreProtocol.swift
@apps/ios/trendy/Protocols/DataStoreFactory.swift

# Models needed for in-memory storage
@apps/ios/trendy/Models/Event.swift
@apps/ios/trendy/Models/EventType.swift
@apps/ios/trendy/Models/Geofence.swift
@apps/ios/trendy/Models/PropertyDefinition.swift
@apps/ios/trendy/Models/PendingMutation.swift

# API models for fixtures
@apps/ios/trendy/Models/API/APIModels.swift

# Existing test support to extend
@apps/ios/trendyTests/TestSupport.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MockDataStore with in-memory state and spy pattern</name>
  <files>apps/ios/trendyTests/Mocks/MockDataStore.swift</files>
  <action>
Create `apps/ios/trendyTests/Mocks/MockDataStore.swift` implementing DataStoreProtocol.

**Important:** DataStoreProtocol is NOT Sendable (ModelContext is not thread-safe). MockDataStore should NOT be Sendable either.

**Structure:**

1. **In-Memory Storage:**
   Use dictionaries keyed by entity ID:
   ```swift
   private var events: [String: Event] = [:]
   private var eventTypes: [String: EventType] = [:]
   private var geofences: [String: Geofence] = [:]
   private var propertyDefinitions: [String: PropertyDefinition] = [:]
   private var pendingMutations: [PendingMutation] = []
   ```

2. **Call Recording (Spy Pattern):**
   ```swift
   struct UpsertEventCall { let id: String; let timestamp: Date }
   struct DeleteEventCall { let id: String; let timestamp: Date }
   struct FindEventCall { let id: String; let timestamp: Date }
   // Similar for other entity types

   private(set) var upsertEventCalls: [UpsertEventCall] = []
   private(set) var deleteEventCalls: [DeleteEventCall] = []
   private(set) var saveCalls: Int = 0
   // etc.
   ```

3. **Error Injection:**
   ```swift
   var throwOnSave: Error?
   var throwOnUpsert: Error?
   var throwOnDelete: Error?
   var throwOnFind: Error?
   ```

4. **Protocol Implementation:**
   Implement all 30 DataStoreProtocol methods. The mock needs to handle SwiftData @Model objects carefully since they normally require a ModelContext.

   **Critical insight:** Since Event, EventType, Geofence, PropertyDefinition are @Model classes, they need a ModelContext to be properly initialized. For testing purposes, use a simplified approach:

   For upsert operations, the mock should:
   - Check if entity exists in dictionary
   - If not, create a minimal instance (the configure closure will set properties)
   - Call configure closure to set properties
   - Store in dictionary
   - Return the entity

   **Example upsert implementation:**
   ```swift
   @discardableResult
   func upsertEvent(id: String, configure: (Event) -> Void) throws -> Event {
       upsertEventCalls.append(UpsertEventCall(id: id, timestamp: Date()))

       if let error = throwOnUpsert { throw error }

       let event: Event
       if let existing = events[id] {
           event = existing
       } else {
           // Create a minimal Event - tests must provide valid EventType
           // For mock purposes, use a placeholder EventType
           let placeholderType = eventTypes.values.first ?? EventType(
               name: "Mock",
               colorHex: "#000000",
               iconName: "circle"
           )
           event = Event(timestamp: Date(), eventType: placeholderType)
           event.id = id
       }

       configure(event)
       events[id] = event
       return event
   }
   ```

   **Note:** The mock stores objects in dictionaries. SwiftData model objects can exist outside a context (they just won't persist). This is acceptable for unit testing.

5. **Helper Methods:**
   ```swift
   func reset() {
       events.removeAll()
       eventTypes.removeAll()
       geofences.removeAll()
       propertyDefinitions.removeAll()
       pendingMutations.removeAll()
       // Clear all call records
       upsertEventCalls.removeAll()
       deleteEventCalls.removeAll()
       saveCalls = 0
       // Clear error injections
       throwOnSave = nil
       throwOnUpsert = nil
       throwOnDelete = nil
       throwOnFind = nil
   }

   // Direct state setters for test setup
   func seedEvent(_ event: Event) {
       events[event.id] = event
   }

   func seedEventType(_ eventType: EventType) {
       eventTypes[eventType.id] = eventType
   }

   func seedGeofence(_ geofence: Geofence) {
       geofences[geofence.id] = geofence
   }

   func seedPropertyDefinition(_ definition: PropertyDefinition) {
       propertyDefinitions[definition.id] = definition
   }

   func seedPendingMutation(_ mutation: PendingMutation) {
       pendingMutations.append(mutation)
   }
   ```

Import `@testable import trendy` and `import Foundation` at the top.
  </action>
  <verify>
Build the test target to verify MockDataStore compiles:
```bash
cd apps/ios && xcodebuild build-for-testing -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(error:|MockDataStore|Build Succeeded)"
```
  </verify>
  <done>
MockDataStore.swift exists in trendyTests/Mocks/, implements all 30 DataStoreProtocol methods, uses in-memory dictionaries for state, has spy pattern call recording, and compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MockDataStoreFactory</name>
  <files>apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift</files>
  <action>
Create `apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift` implementing DataStoreFactory.

**Key points:**
- DataStoreFactory IS Sendable (it crosses actor boundaries)
- MockDataStoreFactory must be `@unchecked Sendable` because it holds a reference to MockDataStore
- The factory returns the same mock instance each time (unlike production which creates fresh contexts)

```swift
import Foundation
@testable import trendy

/// Factory that returns a pre-configured MockDataStore for testing.
/// Conforms to DataStoreFactory so it can be injected into SyncEngine.
///
/// Usage:
/// ```swift
/// let mockStore = MockDataStore()
/// let factory = MockDataStoreFactory(mockStore: mockStore)
/// let syncEngine = SyncEngine(networkClient: mockNetwork, dataStoreFactory: factory)
/// ```
final class MockDataStoreFactory: DataStoreFactory, @unchecked Sendable {
    /// The mock store instance returned by makeDataStore()
    private let mockStore: MockDataStore

    /// Whether makeDataStore() has been called
    private(set) var makeDataStoreCalled = false

    /// Number of times makeDataStore() was called
    private(set) var makeDataStoreCallCount = 0

    init(mockStore: MockDataStore) {
        self.mockStore = mockStore
    }

    /// Returns the mock store instance.
    /// Note: Unlike production factory which creates fresh ModelContext,
    /// this returns the same mock instance for test verification.
    func makeDataStore() -> any DataStoreProtocol {
        makeDataStoreCalled = true
        makeDataStoreCallCount += 1
        return mockStore
    }

    /// Reset call tracking state
    func reset() {
        makeDataStoreCalled = false
        makeDataStoreCallCount = 0
    }
}
```
  </action>
  <verify>
Build the test target to verify MockDataStoreFactory compiles:
```bash
cd apps/ios && xcodebuild build-for-testing -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(error:|MockDataStoreFactory|Build Succeeded)"
```
  </verify>
  <done>
MockDataStoreFactory.swift exists in trendyTests/Mocks/, implements DataStoreFactory, is @unchecked Sendable, returns configured MockDataStore, and compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend TestSupport.swift with API model fixtures</name>
  <files>apps/ios/trendyTests/TestSupport.swift</files>
  <action>
Extend the existing TestSupport.swift with fixtures for API models needed by SyncEngine tests.

**Add to APIModelFixture struct:**

```swift
// MARK: - Change Feed Fixtures

/// Create a ChangeFeedResponse
static func makeChangeFeedResponse(
    changes: [ChangeEntry] = [],
    nextCursor: Int64 = 0,
    hasMore: Bool = false
) -> ChangeFeedResponse {
    ChangeFeedResponse(
        changes: changes,
        nextCursor: nextCursor,
        hasMore: hasMore
    )
}

/// Create a ChangeEntry for create operation
static func makeChangeEntry(
    id: Int64 = 1,
    entityType: String = "event",
    operation: String = "create",
    entityId: String = "entity-1",
    data: ChangeEntryData? = nil,
    deletedAt: Date? = nil
) -> ChangeEntry {
    ChangeEntry(
        id: id,
        entityType: entityType,
        operation: operation,
        entityId: entityId,
        data: data,
        deletedAt: deletedAt,
        createdAt: Date(timeIntervalSince1970: 1704067200)
    )
}

// MARK: - Geofence Fixtures

/// Create an APIGeofence
static func makeAPIGeofence(
    id: String = "geo-1",
    userId: String = "user-1",
    name: String = "Home",
    latitude: Double = 37.7749,
    longitude: Double = -122.4194,
    radius: Double = 100.0,
    eventTypeEntryId: String? = nil,
    eventTypeExitId: String? = nil,
    isActive: Bool = true,
    notifyOnEntry: Bool = true,
    notifyOnExit: Bool = false
) -> APIGeofence {
    // APIGeofence uses custom decoder, but we can create JSON and decode
    // For simplicity, use a helper that creates the JSON and decodes
    let json: [String: Any] = [
        "id": id,
        "user_id": userId,
        "name": name,
        "latitude": latitude,
        "longitude": longitude,
        "radius": radius,
        "event_type_entry_id": eventTypeEntryId as Any,
        "event_type_exit_id": eventTypeExitId as Any,
        "is_active": isActive,
        "notify_on_entry": notifyOnEntry,
        "notify_on_exit": notifyOnExit,
        "ios_region_identifier": nil as Any?,
        "created_at": ISO8601DateFormatter().string(from: Date(timeIntervalSince1970: 1704067200)),
        "updated_at": ISO8601DateFormatter().string(from: Date(timeIntervalSince1970: 1704067200))
    ]
    let data = try! JSONSerialization.data(withJSONObject: json.compactMapValues { $0 })
    let decoder = JSONDecoder()
    decoder.dateDecodingStrategy = .iso8601
    return try! decoder.decode(APIGeofence.self, from: data)
}

/// Create a CreateGeofenceRequest
static func makeCreateGeofenceRequest(
    id: String? = nil,
    name: String = "Test Geofence",
    latitude: Double = 37.7749,
    longitude: Double = -122.4194,
    radius: Double = 100.0,
    eventTypeEntryId: String? = nil,
    eventTypeExitId: String? = nil,
    isActive: Bool = true,
    notifyOnEntry: Bool = true,
    notifyOnExit: Bool = false
) -> CreateGeofenceRequest {
    CreateGeofenceRequest(
        id: id,
        name: name,
        latitude: latitude,
        longitude: longitude,
        radius: radius,
        eventTypeEntryId: eventTypeEntryId,
        eventTypeExitId: eventTypeExitId,
        isActive: isActive,
        notifyOnEntry: notifyOnEntry,
        notifyOnExit: notifyOnExit
    )
}

// MARK: - Property Definition Fixtures

/// Create an APIPropertyDefinition
static func makeAPIPropertyDefinition(
    id: String = "propdef-1",
    eventTypeId: String = "type-1",
    userId: String = "user-1",
    key: String = "duration",
    label: String = "Duration",
    propertyType: String = "number",
    options: [String]? = nil,
    displayOrder: Int = 0
) -> APIPropertyDefinition {
    APIPropertyDefinition(
        id: id,
        eventTypeId: eventTypeId,
        userId: userId,
        key: key,
        label: label,
        propertyType: propertyType,
        options: options,
        defaultValue: nil,
        displayOrder: displayOrder,
        createdAt: Date(timeIntervalSince1970: 1704067200),
        updatedAt: Date(timeIntervalSince1970: 1704067200)
    )
}

/// Create a CreatePropertyDefinitionRequest
static func makeCreatePropertyDefinitionRequest(
    id: String = "propdef-1",
    eventTypeId: String = "type-1",
    key: String = "duration",
    label: String = "Duration",
    propertyType: String = "number",
    options: [String]? = nil,
    displayOrder: Int = 0
) -> CreatePropertyDefinitionRequest {
    CreatePropertyDefinitionRequest(
        id: id,
        eventTypeId: eventTypeId,
        key: key,
        label: label,
        propertyType: propertyType,
        options: options,
        defaultValue: nil,
        displayOrder: displayOrder
    )
}

// MARK: - Batch Response Fixtures

/// Create a BatchCreateEventsResponse
static func makeBatchCreateEventsResponse(
    created: [APIEvent] = [],
    errors: [BatchError]? = nil,
    total: Int? = nil,
    success: Int? = nil,
    failed: Int? = nil
) -> BatchCreateEventsResponse {
    BatchCreateEventsResponse(
        created: created,
        errors: errors,
        total: total ?? created.count,
        success: success ?? created.count,
        failed: failed ?? (errors?.count ?? 0)
    )
}

/// Create a BatchError
static func makeBatchError(
    index: Int = 0,
    message: String = "Validation failed"
) -> BatchError {
    BatchError(index: index, message: message)
}

// MARK: - Event Type Request Fixtures

/// Create a CreateEventTypeRequest
static func makeCreateEventTypeRequest(
    id: String = "type-1",
    name: String = "Workout",
    color: String = "#FF5733",
    icon: String = "figure.run"
) -> CreateEventTypeRequest {
    CreateEventTypeRequest(
        id: id,
        name: name,
        color: color,
        icon: icon
    )
}

/// Create an UpdateEventTypeRequest
static func makeUpdateEventTypeRequest(
    name: String? = nil,
    color: String? = nil,
    icon: String? = nil
) -> UpdateEventTypeRequest {
    UpdateEventTypeRequest(
        name: name,
        color: color,
        icon: icon
    )
}
```
  </action>
  <verify>
Build the test target and run existing tests to ensure fixtures work:
```bash
cd apps/ios && xcodebuild build-for-testing -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(error:|TestSupport|Build Succeeded)"
```
  </verify>
  <done>
TestSupport.swift extended with fixtures for ChangeFeedResponse, ChangeEntry, APIGeofence, CreateGeofenceRequest, APIPropertyDefinition, CreatePropertyDefinitionRequest, BatchCreateEventsResponse, BatchError, CreateEventTypeRequest, UpdateEventTypeRequest. All fixtures compile successfully.
  </done>
</task>

</tasks>

<verification>
1. MockDataStore.swift exists in apps/ios/trendyTests/Mocks/
2. MockDataStore implements all 30 DataStoreProtocol methods
3. MockDataStore uses in-memory dictionaries for state
4. MockDataStore has spy pattern call recording
5. MockDataStoreFactory.swift exists and implements DataStoreFactory
6. MockDataStoreFactory is @unchecked Sendable
7. TestSupport.swift has fixtures for ChangeFeedResponse, ChangeEntry, APIGeofence, APIPropertyDefinition, BatchCreateEventsResponse
8. Test target builds successfully
</verification>

<success_criteria>
- MockDataStore conforms to DataStoreProtocol (compiler verified)
- MockDataStoreFactory conforms to DataStoreFactory (compiler verified)
- MockDataStoreFactory can be passed across actor boundaries (Sendable)
- Tests can seed mock state and verify operations via spy pattern
- All API model fixtures compile and create valid instances
- Test target builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/16-test-infrastructure/16-02-SUMMARY.md`
</output>
