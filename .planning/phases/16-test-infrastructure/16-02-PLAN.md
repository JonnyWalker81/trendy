---
phase: 16-test-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendyTests/Mocks/MockDataStore.swift
  - apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift
  - apps/ios/trendyTests/TestSupport.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "MockDataStore provides in-memory state management for isolated testing"
    - "MockDataStoreFactory can be injected into SyncEngine instead of DefaultDataStoreFactory"
    - "Tests can verify which data store methods were called"
    - "Test fixtures exist for all API models needed by SyncEngine tests"
  artifacts:
    - path: "apps/ios/trendyTests/Mocks/MockDataStore.swift"
      provides: "MockDataStore implementing DataStoreProtocol"
      min_lines: 300
      exports: ["MockDataStore"]
    - path: "apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift"
      provides: "MockDataStoreFactory implementing DataStoreFactory"
      min_lines: 20
      exports: ["MockDataStoreFactory"]
    - path: "apps/ios/trendyTests/TestSupport.swift"
      provides: "Extended API model fixtures"
      contains: "makeChangeFeedResponse"
  key_links:
    - from: "MockDataStore"
      to: "DataStoreProtocol"
      via: "protocol conformance"
      pattern: "final class MockDataStore: DataStoreProtocol"
    - from: "MockDataStoreFactory"
      to: "DataStoreFactory"
      via: "protocol conformance"
      pattern: "final class MockDataStoreFactory: DataStoreFactory"
---

<objective>
Create MockDataStore and MockDataStoreFactory for testing SyncEngine data persistence, plus extend TestSupport.swift with fixtures for ChangeFeedResponse and other API models.

Purpose: Enable isolated unit testing of SyncEngine by replacing real SwiftData persistence with in-memory mock state. The factory pattern allows passing mocks across actor boundaries (factory is Sendable, store is not).

Output:
- MockDataStore.swift implementing DataStoreProtocol with in-memory test ModelContainer
- MockDataStoreFactory.swift implementing DataStoreFactory
- Extended TestSupport.swift with fixtures for ChangeFeedResponse, ChangeEntry, APIGeofence, APIPropertyDefinition
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-test-infrastructure/16-RESEARCH.md

# Protocols to implement
@apps/ios/trendy/Protocols/DataStoreProtocol.swift
@apps/ios/trendy/Protocols/DataStoreFactory.swift

# Models needed for in-memory storage
@apps/ios/trendy/Models/Event.swift
@apps/ios/trendy/Models/EventType.swift
@apps/ios/trendy/Models/Geofence.swift
@apps/ios/trendy/Models/PropertyDefinition.swift
@apps/ios/trendy/Models/PendingMutation.swift

# API models for fixtures
@apps/ios/trendy/Models/API/APIModels.swift

# Existing test support to extend
@apps/ios/trendyTests/TestSupport.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MockDataStore with in-memory ModelContainer and spy pattern</name>
  <files>apps/ios/trendyTests/Mocks/MockDataStore.swift</files>
  <action>
Create `apps/ios/trendyTests/Mocks/MockDataStore.swift` implementing DataStoreProtocol.

**Important:** DataStoreProtocol is NOT Sendable (ModelContext is not thread-safe). MockDataStore should NOT be Sendable either.

**Critical SwiftData Constraint:** Since Event, EventType, Geofence, PropertyDefinition are @Model classes, they REQUIRE a ModelContext for initialization. Use an in-memory test ModelContainer to provide this context.

**Structure:**

1. **In-Memory ModelContainer Setup:**
   ```swift
   import Foundation
   import SwiftData
   @testable import trendy

   /// Mock implementation of DataStoreProtocol for unit testing.
   /// Uses an in-memory ModelContainer to satisfy SwiftData's @Model requirements.
   final class MockDataStore: DataStoreProtocol {
       /// In-memory container for @Model objects
       private let modelContainer: ModelContainer
       private let modelContext: ModelContext

       /// Convenience accessors for test verification
       private(set) var storedEvents: [String: Event] = [:]
       private(set) var storedEventTypes: [String: EventType] = [:]
       private(set) var storedGeofences: [String: Geofence] = [:]
       private(set) var storedPropertyDefinitions: [String: PropertyDefinition] = [:]
       private(set) var storedPendingMutations: [PendingMutation] = []

       init() {
           // Create in-memory test container - models exist only in RAM
           let schema = Schema([
               Event.self,
               EventType.self,
               Geofence.self,
               PropertyDefinition.self,
               PendingMutation.self
           ])
           let config = ModelConfiguration(isStoredInMemoryOnly: true)
           do {
               modelContainer = try ModelContainer(for: schema, configurations: config)
               modelContext = ModelContext(modelContainer)
           } catch {
               fatalError("Failed to create test ModelContainer: \(error)")
           }
       }
   ```

2. **Call Recording (Spy Pattern):**
   ```swift
   struct UpsertEventCall { let id: String; let timestamp: Date }
   struct DeleteEventCall { let id: String; let timestamp: Date }
   struct FindEventCall { let id: String; let timestamp: Date }
   struct UpsertEventTypeCall { let id: String; let timestamp: Date }
   struct DeleteEventTypeCall { let id: String; let timestamp: Date }
   struct FindEventTypeCall { let id: String; let timestamp: Date }
   struct UpsertGeofenceCall { let id: String; let timestamp: Date }
   struct DeleteGeofenceCall { let id: String; let timestamp: Date }
   struct FindGeofenceCall { let id: String; let timestamp: Date }
   struct UpsertPropertyDefinitionCall { let id: String; let timestamp: Date }
   struct DeletePropertyDefinitionCall { let id: String; let timestamp: Date }
   struct FindPropertyDefinitionCall { let id: String; let timestamp: Date }
   struct InsertMutationCall { let entityType: String; let entityId: String; let timestamp: Date }
   struct HasPendingMutationCall { let entityId: String; let entityType: String; let operation: String; let timestamp: Date }
   struct MarkSyncedCall { let id: String; let timestamp: Date }

   private(set) var upsertEventCalls: [UpsertEventCall] = []
   private(set) var deleteEventCalls: [DeleteEventCall] = []
   private(set) var findEventCalls: [FindEventCall] = []
   private(set) var upsertEventTypeCalls: [UpsertEventTypeCall] = []
   private(set) var deleteEventTypeCalls: [DeleteEventTypeCall] = []
   private(set) var findEventTypeCalls: [FindEventTypeCall] = []
   private(set) var upsertGeofenceCalls: [UpsertGeofenceCall] = []
   private(set) var deleteGeofenceCalls: [DeleteGeofenceCall] = []
   private(set) var findGeofenceCalls: [FindGeofenceCall] = []
   private(set) var upsertPropertyDefinitionCalls: [UpsertPropertyDefinitionCall] = []
   private(set) var deletePropertyDefinitionCalls: [DeletePropertyDefinitionCall] = []
   private(set) var findPropertyDefinitionCalls: [FindPropertyDefinitionCall] = []
   private(set) var insertMutationCalls: [InsertMutationCall] = []
   private(set) var hasPendingMutationCalls: [HasPendingMutationCall] = []
   private(set) var markEventSyncedCalls: [MarkSyncedCall] = []
   private(set) var markEventTypeSyncedCalls: [MarkSyncedCall] = []
   private(set) var markGeofenceSyncedCalls: [MarkSyncedCall] = []
   private(set) var markPropertyDefinitionSyncedCalls: [MarkSyncedCall] = []
   private(set) var saveCalls: Int = 0
   private(set) var fetchAllEventsCalls: Int = 0
   private(set) var fetchAllEventTypesCalls: Int = 0
   private(set) var fetchAllGeofencesCalls: Int = 0
   private(set) var fetchAllPropertyDefinitionsCalls: Int = 0
   private(set) var deleteAllEventsCalls: Int = 0
   private(set) var deleteAllEventTypesCalls: Int = 0
   private(set) var deleteAllGeofencesCalls: Int = 0
   private(set) var deleteAllPropertyDefinitionsCalls: Int = 0
   private(set) var fetchPendingMutationsCalls: Int = 0
   ```

3. **Error Injection:**
   ```swift
   var throwOnSave: Error?
   var throwOnUpsert: Error?
   var throwOnDelete: Error?
   var throwOnFind: Error?
   var throwOnFetchAll: Error?
   var throwOnInsertMutation: Error?
   var throwOnMarkSynced: Error?
   ```

4. **Protocol Implementation with ModelContext:**
   Implement all 29 DataStoreProtocol methods using the in-memory ModelContext.

   **UPSERT METHODS (4 total):**

   Example upsertEvent:
   ```swift
   @discardableResult
   func upsertEvent(id: String, configure: (Event) -> Void) throws -> Event {
       upsertEventCalls.append(UpsertEventCall(id: id, timestamp: Date()))

       if let error = throwOnUpsert { throw error }

       let event: Event
       if let existing = storedEvents[id] {
           event = existing
       } else {
           // Create Event with ModelContext - use a default EventType
           let defaultType = try getOrCreateDefaultEventType()
           event = Event(timestamp: Date(), eventType: defaultType)
           event.id = id
           modelContext.insert(event)
       }

       configure(event)
       storedEvents[id] = event
       return event
   }

   /// Helper to ensure we have a valid EventType for Event creation
   private func getOrCreateDefaultEventType() throws -> EventType {
       if let existingType = storedEventTypes.values.first {
           return existingType
       }
       // Create a default type in the context
       let defaultType = EventType(name: "MockDefault", colorHex: "#888888", iconName: "circle")
       modelContext.insert(defaultType)
       storedEventTypes[defaultType.id] = defaultType
       return defaultType
   }
   ```

   Example upsertEventType:
   ```swift
   @discardableResult
   func upsertEventType(id: String, configure: (EventType) -> Void) throws -> EventType {
       upsertEventTypeCalls.append(UpsertEventTypeCall(id: id, timestamp: Date()))

       if let error = throwOnUpsert { throw error }

       let eventType: EventType
       if let existing = storedEventTypes[id] {
           eventType = existing
       } else {
           eventType = EventType(name: "Placeholder", colorHex: "#000000", iconName: "circle")
           eventType.id = id
           modelContext.insert(eventType)
       }

       configure(eventType)
       storedEventTypes[id] = eventType
       return eventType
   }
   ```

   **Pattern for remaining upserts:** Implement `upsertGeofence` and `upsertPropertyDefinition` following the same pattern:
   - Record call with id and timestamp
   - Check throwOnUpsert
   - Check if existing in storedGeofences/storedPropertyDefinitions dictionary
   - If not existing, create new model object with placeholder values, set id, insert into modelContext
   - Note: upsertPropertyDefinition takes additional `eventTypeId` parameter - look up or create the EventType first
   - Call configure closure
   - Store in dictionary
   - Return object

   **DELETE METHODS (4 total):**

   Example deleteEvent:
   ```swift
   func deleteEvent(id: String) throws {
       deleteEventCalls.append(DeleteEventCall(id: id, timestamp: Date()))

       if let error = throwOnDelete { throw error }

       if let event = storedEvents.removeValue(forKey: id) {
           modelContext.delete(event)
       }
   }
   ```

   **Pattern for remaining deletes:** Implement `deleteEventType`, `deleteGeofence`, `deletePropertyDefinition` following the same pattern:
   - Record call with id and timestamp to appropriate calls array
   - Check throwOnDelete
   - Remove from storedEventTypes/storedGeofences/storedPropertyDefinitions dictionary
   - If found, delete from modelContext

   **FIND METHODS (4 total):**

   Example findEvent:
   ```swift
   func findEvent(id: String) throws -> Event? {
       findEventCalls.append(FindEventCall(id: id, timestamp: Date()))

       if let error = throwOnFind { throw error }

       return storedEvents[id]
   }
   ```

   **Pattern for remaining finds:** Implement `findEventType`, `findGeofence`, `findPropertyDefinition` following the same pattern:
   - Record call with id and timestamp to appropriate calls array
   - Check throwOnFind
   - Return from storedEventTypes/storedGeofences/storedPropertyDefinitions dictionary (nil if not found)

   **FETCH ALL METHODS (4 total):**

   Example fetchAllEvents:
   ```swift
   func fetchAllEvents() throws -> [Event] {
       fetchAllEventsCalls += 1

       if let error = throwOnFetchAll { throw error }

       return Array(storedEvents.values)
   }
   ```

   **Pattern for remaining fetchAlls:** Implement `fetchAllEventTypes`, `fetchAllGeofences`, `fetchAllPropertyDefinitions` following the same pattern:
   - Increment appropriate calls counter
   - Check throwOnFetchAll
   - Return Array of values from storedEventTypes/storedGeofences/storedPropertyDefinitions dictionary

   **DELETE ALL METHODS (4 total):**

   Example deleteAllEvents:
   ```swift
   func deleteAllEvents() throws {
       deleteAllEventsCalls += 1

       if let error = throwOnDelete { throw error }

       for event in storedEvents.values {
           modelContext.delete(event)
       }
       storedEvents.removeAll()
   }
   ```

   **Pattern for remaining deleteAlls:** Implement `deleteAllEventTypes`, `deleteAllGeofences`, `deleteAllPropertyDefinitions` following the same pattern:
   - Increment appropriate calls counter (deleteAllEventTypesCalls, deleteAllGeofencesCalls, deleteAllPropertyDefinitionsCalls)
   - Check throwOnDelete
   - Iterate storedEventTypes/storedGeofences/storedPropertyDefinitions values, delete each from modelContext
   - Call removeAll() on the dictionary

   **PENDING MUTATION METHODS (4 total):**

   insertPendingMutation:
   ```swift
   func insertPendingMutation(_ mutation: PendingMutation) throws {
       insertMutationCalls.append(InsertMutationCall(
           entityType: mutation.entityType.rawValue,
           entityId: mutation.entityId,
           timestamp: Date()
       ))

       if let error = throwOnInsertMutation { throw error }

       modelContext.insert(mutation)
       storedPendingMutations.append(mutation)
   }
   ```

   fetchPendingMutations:
   ```swift
   func fetchPendingMutations() throws -> [PendingMutation] {
       fetchPendingMutationsCalls += 1

       if let error = throwOnFetchAll { throw error }

       return storedPendingMutations
   }
   ```

   hasPendingMutation:
   ```swift
   func hasPendingMutation(entityId: String, entityType: MutationEntityType, operation: MutationOperation) throws -> Bool {
       hasPendingMutationCalls.append(HasPendingMutationCall(
           entityId: entityId,
           entityType: entityType.rawValue,
           operation: operation.rawValue,
           timestamp: Date()
       ))

       if let error = throwOnFind { throw error }

       return storedPendingMutations.contains { mutation in
           mutation.entityId == entityId &&
           mutation.entityType == entityType &&
           mutation.operation == operation
       }
   }
   ```

   deletePendingMutation:
   ```swift
   func deletePendingMutation(_ mutation: PendingMutation) throws {
       if let error = throwOnDelete { throw error }

       storedPendingMutations.removeAll { $0.id == mutation.id }
       modelContext.delete(mutation)
   }
   ```

   **MARK SYNCED METHODS (4 total):**

   Example markEventSynced:
   ```swift
   func markEventSynced(id: String) throws {
       markEventSyncedCalls.append(MarkSyncedCall(id: id, timestamp: Date()))

       if let error = throwOnMarkSynced { throw error }

       if let event = storedEvents[id] {
           event.syncStatus = .synced
       }
   }
   ```

   **Pattern for remaining markSynced:** Implement `markEventTypeSynced`, `markGeofenceSynced`, `markPropertyDefinitionSynced` following the same pattern:
   - Record call with id and timestamp to appropriate calls array (markEventTypeSyncedCalls, markGeofenceSyncedCalls, markPropertyDefinitionSyncedCalls)
   - Check throwOnMarkSynced
   - Look up in storedEventTypes/storedGeofences/storedPropertyDefinitions dictionary
   - If found, set syncStatus = .synced

   **SAVE METHOD (1 total):**

   ```swift
   func save() throws {
       saveCalls += 1

       if let error = throwOnSave { throw error }

       // In-memory ModelContext - just ensure state is consistent
       try modelContext.save()
   }
   ```

5. **Helper Methods for Test Setup:**
   ```swift
   /// Reset all state and call records
   func reset() {
       // Clear stored entities
       for event in storedEvents.values { modelContext.delete(event) }
       for eventType in storedEventTypes.values { modelContext.delete(eventType) }
       for geofence in storedGeofences.values { modelContext.delete(geofence) }
       for propDef in storedPropertyDefinitions.values { modelContext.delete(propDef) }
       for mutation in storedPendingMutations { modelContext.delete(mutation) }

       storedEvents.removeAll()
       storedEventTypes.removeAll()
       storedGeofences.removeAll()
       storedPropertyDefinitions.removeAll()
       storedPendingMutations.removeAll()

       // Clear call records
       upsertEventCalls.removeAll()
       deleteEventCalls.removeAll()
       findEventCalls.removeAll()
       upsertEventTypeCalls.removeAll()
       deleteEventTypeCalls.removeAll()
       findEventTypeCalls.removeAll()
       upsertGeofenceCalls.removeAll()
       deleteGeofenceCalls.removeAll()
       findGeofenceCalls.removeAll()
       upsertPropertyDefinitionCalls.removeAll()
       deletePropertyDefinitionCalls.removeAll()
       findPropertyDefinitionCalls.removeAll()
       insertMutationCalls.removeAll()
       hasPendingMutationCalls.removeAll()
       markEventSyncedCalls.removeAll()
       markEventTypeSyncedCalls.removeAll()
       markGeofenceSyncedCalls.removeAll()
       markPropertyDefinitionSyncedCalls.removeAll()
       saveCalls = 0
       fetchAllEventsCalls = 0
       fetchAllEventTypesCalls = 0
       fetchAllGeofencesCalls = 0
       fetchAllPropertyDefinitionsCalls = 0
       deleteAllEventsCalls = 0
       deleteAllEventTypesCalls = 0
       deleteAllGeofencesCalls = 0
       deleteAllPropertyDefinitionsCalls = 0
       fetchPendingMutationsCalls = 0

       // Clear error injections
       throwOnSave = nil
       throwOnUpsert = nil
       throwOnDelete = nil
       throwOnFind = nil
       throwOnFetchAll = nil
       throwOnInsertMutation = nil
       throwOnMarkSynced = nil
   }

   // Direct state seeding for test setup - inserts into ModelContext
   func seedEventType(_ configure: (EventType) -> Void) -> EventType {
       let eventType = EventType(name: "Seeded", colorHex: "#000000", iconName: "circle")
       modelContext.insert(eventType)
       configure(eventType)
       storedEventTypes[eventType.id] = eventType
       return eventType
   }

   func seedEvent(eventType: EventType, _ configure: (Event) -> Void) -> Event {
       let event = Event(timestamp: Date(), eventType: eventType)
       modelContext.insert(event)
       configure(event)
       storedEvents[event.id] = event
       return event
   }

   func seedGeofence(_ configure: (Geofence) -> Void) -> Geofence {
       let geofence = Geofence(name: "Seeded", latitude: 0, longitude: 0, radius: 100)
       modelContext.insert(geofence)
       configure(geofence)
       storedGeofences[geofence.id] = geofence
       return geofence
   }

   func seedPropertyDefinition(eventType: EventType, _ configure: (PropertyDefinition) -> Void) -> PropertyDefinition {
       let propDef = PropertyDefinition(eventType: eventType, key: "seeded", label: "Seeded", propertyType: .text)
       modelContext.insert(propDef)
       configure(propDef)
       storedPropertyDefinitions[propDef.id] = propDef
       return propDef
   }

   func seedPendingMutation(entityType: MutationEntityType, entityId: String, operation: MutationOperation, payload: Data? = nil) -> PendingMutation {
       let mutation = PendingMutation(entityType: entityType, entityId: entityId, operation: operation, payload: payload)
       modelContext.insert(mutation)
       storedPendingMutations.append(mutation)
       return mutation
   }
   ```

Import `@testable import trendy`, `import Foundation`, and `import SwiftData` at the top.
  </action>
  <verify>
Build the test target to verify MockDataStore compiles:
```bash
cd apps/ios && xcodebuild build-for-testing -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(error:|MockDataStore|Build Succeeded)"
```
  </verify>
  <done>
MockDataStore.swift exists in trendyTests/Mocks/, implements all 29 DataStoreProtocol methods, uses in-memory ModelContainer for SwiftData compatibility, has spy pattern call recording, and compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MockDataStoreFactory</name>
  <files>apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift</files>
  <action>
Create `apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift` implementing DataStoreFactory.

**Key points:**
- DataStoreFactory IS Sendable (it crosses actor boundaries)
- MockDataStoreFactory must be `@unchecked Sendable` because it holds a reference to MockDataStore
- The factory returns the same mock instance each time (unlike production which creates fresh contexts)

```swift
import Foundation
@testable import trendy

/// Factory that returns a pre-configured MockDataStore for testing.
/// Conforms to DataStoreFactory so it can be injected into SyncEngine.
///
/// Usage:
/// ```swift
/// let mockStore = MockDataStore()
/// let factory = MockDataStoreFactory(mockStore: mockStore)
/// let syncEngine = SyncEngine(networkClient: mockNetwork, dataStoreFactory: factory)
/// ```
final class MockDataStoreFactory: DataStoreFactory, @unchecked Sendable {
    /// The mock store instance returned by makeDataStore()
    private let mockStore: MockDataStore

    /// Whether makeDataStore() has been called
    private(set) var makeDataStoreCalled = false

    /// Number of times makeDataStore() was called
    private(set) var makeDataStoreCallCount = 0

    init(mockStore: MockDataStore) {
        self.mockStore = mockStore
    }

    /// Returns the mock store instance.
    /// Note: Unlike production factory which creates fresh ModelContext,
    /// this returns the same mock instance for test verification.
    func makeDataStore() -> any DataStoreProtocol {
        makeDataStoreCalled = true
        makeDataStoreCallCount += 1
        return mockStore
    }

    /// Reset call tracking state
    func reset() {
        makeDataStoreCalled = false
        makeDataStoreCallCount = 0
    }
}
```
  </action>
  <verify>
Build the test target to verify MockDataStoreFactory compiles:
```bash
cd apps/ios && xcodebuild build-for-testing -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(error:|MockDataStoreFactory|Build Succeeded)"
```
  </verify>
  <done>
MockDataStoreFactory.swift exists in trendyTests/Mocks/, implements DataStoreFactory, is @unchecked Sendable, returns configured MockDataStore, and compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend TestSupport.swift with API model fixtures</name>
  <files>apps/ios/trendyTests/TestSupport.swift</files>
  <action>
Extend the existing TestSupport.swift with fixtures for API models needed by SyncEngine tests.

**Add to APIModelFixture struct:**

```swift
// MARK: - Change Feed Fixtures

/// Create a ChangeFeedResponse
static func makeChangeFeedResponse(
    changes: [ChangeEntry] = [],
    nextCursor: Int64 = 0,
    hasMore: Bool = false
) -> ChangeFeedResponse {
    ChangeFeedResponse(
        changes: changes,
        nextCursor: nextCursor,
        hasMore: hasMore
    )
}

/// Create a ChangeEntry for create operation
static func makeChangeEntry(
    id: Int64 = 1,
    entityType: String = "event",
    operation: String = "create",
    entityId: String = "entity-1",
    data: ChangeEntryData? = nil,
    deletedAt: Date? = nil
) -> ChangeEntry {
    ChangeEntry(
        id: id,
        entityType: entityType,
        operation: operation,
        entityId: entityId,
        data: data,
        deletedAt: deletedAt,
        createdAt: Date(timeIntervalSince1970: 1704067200)
    )
}

// MARK: - Geofence Fixtures

/// Create an APIGeofence
static func makeAPIGeofence(
    id: String = "geo-1",
    userId: String = "user-1",
    name: String = "Home",
    latitude: Double = 37.7749,
    longitude: Double = -122.4194,
    radius: Double = 100.0,
    eventTypeEntryId: String? = nil,
    eventTypeExitId: String? = nil,
    isActive: Bool = true,
    notifyOnEntry: Bool = true,
    notifyOnExit: Bool = false
) -> APIGeofence {
    // APIGeofence uses custom decoder, but we can create JSON and decode
    // For simplicity, use a helper that creates the JSON and decodes
    let json: [String: Any] = [
        "id": id,
        "user_id": userId,
        "name": name,
        "latitude": latitude,
        "longitude": longitude,
        "radius": radius,
        "event_type_entry_id": eventTypeEntryId as Any,
        "event_type_exit_id": eventTypeExitId as Any,
        "is_active": isActive,
        "notify_on_entry": notifyOnEntry,
        "notify_on_exit": notifyOnExit,
        "ios_region_identifier": nil as Any?,
        "created_at": ISO8601DateFormatter().string(from: Date(timeIntervalSince1970: 1704067200)),
        "updated_at": ISO8601DateFormatter().string(from: Date(timeIntervalSince1970: 1704067200))
    ]
    let data = try! JSONSerialization.data(withJSONObject: json.compactMapValues { $0 })
    let decoder = JSONDecoder()
    decoder.dateDecodingStrategy = .iso8601
    return try! decoder.decode(APIGeofence.self, from: data)
}

/// Create a CreateGeofenceRequest
static func makeCreateGeofenceRequest(
    id: String? = nil,
    name: String = "Test Geofence",
    latitude: Double = 37.7749,
    longitude: Double = -122.4194,
    radius: Double = 100.0,
    eventTypeEntryId: String? = nil,
    eventTypeExitId: String? = nil,
    isActive: Bool = true,
    notifyOnEntry: Bool = true,
    notifyOnExit: Bool = false
) -> CreateGeofenceRequest {
    CreateGeofenceRequest(
        id: id,
        name: name,
        latitude: latitude,
        longitude: longitude,
        radius: radius,
        eventTypeEntryId: eventTypeEntryId,
        eventTypeExitId: eventTypeExitId,
        isActive: isActive,
        notifyOnEntry: notifyOnEntry,
        notifyOnExit: notifyOnExit
    )
}

// MARK: - Property Definition Fixtures

/// Create an APIPropertyDefinition
static func makeAPIPropertyDefinition(
    id: String = "propdef-1",
    eventTypeId: String = "type-1",
    userId: String = "user-1",
    key: String = "duration",
    label: String = "Duration",
    propertyType: String = "number",
    options: [String]? = nil,
    displayOrder: Int = 0
) -> APIPropertyDefinition {
    APIPropertyDefinition(
        id: id,
        eventTypeId: eventTypeId,
        userId: userId,
        key: key,
        label: label,
        propertyType: propertyType,
        options: options,
        defaultValue: nil,
        displayOrder: displayOrder,
        createdAt: Date(timeIntervalSince1970: 1704067200),
        updatedAt: Date(timeIntervalSince1970: 1704067200)
    )
}

/// Create a CreatePropertyDefinitionRequest
static func makeCreatePropertyDefinitionRequest(
    id: String = "propdef-1",
    eventTypeId: String = "type-1",
    key: String = "duration",
    label: String = "Duration",
    propertyType: String = "number",
    options: [String]? = nil,
    displayOrder: Int = 0
) -> CreatePropertyDefinitionRequest {
    CreatePropertyDefinitionRequest(
        id: id,
        eventTypeId: eventTypeId,
        key: key,
        label: label,
        propertyType: propertyType,
        options: options,
        defaultValue: nil,
        displayOrder: displayOrder
    )
}

// MARK: - Batch Response Fixtures

/// Create a BatchCreateEventsResponse
static func makeBatchCreateEventsResponse(
    created: [APIEvent] = [],
    errors: [BatchError]? = nil,
    total: Int? = nil,
    success: Int? = nil,
    failed: Int? = nil
) -> BatchCreateEventsResponse {
    BatchCreateEventsResponse(
        created: created,
        errors: errors,
        total: total ?? created.count,
        success: success ?? created.count,
        failed: failed ?? (errors?.count ?? 0)
    )
}

/// Create a BatchError
static func makeBatchError(
    index: Int = 0,
    message: String = "Validation failed"
) -> BatchError {
    BatchError(index: index, message: message)
}

// MARK: - Event Type Request Fixtures

/// Create a CreateEventTypeRequest
static func makeCreateEventTypeRequest(
    id: String = "type-1",
    name: String = "Workout",
    color: String = "#FF5733",
    icon: String = "figure.run"
) -> CreateEventTypeRequest {
    CreateEventTypeRequest(
        id: id,
        name: name,
        color: color,
        icon: icon
    )
}

/// Create an UpdateEventTypeRequest
static func makeUpdateEventTypeRequest(
    name: String? = nil,
    color: String? = nil,
    icon: String? = nil
) -> UpdateEventTypeRequest {
    UpdateEventTypeRequest(
        name: name,
        color: color,
        icon: icon
    )
}
```
  </action>
  <verify>
Build the test target and run existing tests to ensure fixtures work:
```bash
cd apps/ios && xcodebuild build-for-testing -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "(error:|TestSupport|Build Succeeded)"
```
  </verify>
  <done>
TestSupport.swift extended with fixtures for ChangeFeedResponse, ChangeEntry, APIGeofence, CreateGeofenceRequest, APIPropertyDefinition, CreatePropertyDefinitionRequest, BatchCreateEventsResponse, BatchError, CreateEventTypeRequest, UpdateEventTypeRequest. All fixtures compile successfully.
  </done>
</task>

</tasks>

<verification>
1. MockDataStore.swift exists in apps/ios/trendyTests/Mocks/
2. MockDataStore implements all 29 DataStoreProtocol methods
3. MockDataStore uses in-memory ModelContainer for SwiftData @Model compatibility
4. MockDataStore has spy pattern call recording
5. MockDataStoreFactory.swift exists and implements DataStoreFactory
6. MockDataStoreFactory is @unchecked Sendable
7. TestSupport.swift has fixtures for ChangeFeedResponse, ChangeEntry, APIGeofence, APIPropertyDefinition, BatchCreateEventsResponse
8. Test target builds successfully
</verification>

<success_criteria>
- MockDataStore conforms to DataStoreProtocol (compiler verified)
- MockDataStore uses in-memory ModelContainer (isStoredInMemoryOnly: true)
- MockDataStoreFactory conforms to DataStoreFactory (compiler verified)
- MockDataStoreFactory can be passed across actor boundaries (Sendable)
- Tests can seed mock state and verify operations via spy pattern
- All API model fixtures compile and create valid instances
- Test target builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/16-test-infrastructure/16-02-SUMMARY.md`
</output>
