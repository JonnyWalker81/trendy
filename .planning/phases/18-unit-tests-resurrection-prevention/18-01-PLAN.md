---
phase: 18-unit-tests-resurrection-prevention
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendyTests/SyncEngine/ResurrectionPreventionTests.swift
autonomous: true

must_haves:
  truths:
    - "Deleted items are not re-created when pullChanges receives CREATE entries for them"
    - "pendingDeleteIds is populated from PendingMutation table before change processing"
    - "Both in-memory set and SwiftData fallback paths prevent resurrection"
    - "Cursor advances correctly during sync operations with pending deletes"
    - "pendingDeleteIds is cleared after delete mutations are confirmed server-side"
  artifacts:
    - path: "apps/ios/trendyTests/SyncEngine/ResurrectionPreventionTests.swift"
      provides: "Resurrection prevention unit tests"
      min_lines: 300
  key_links:
    - from: "ResurrectionPreventionTests.swift"
      to: "SyncEngine.pendingDeleteIds"
      via: "seedPendingMutation with .delete operation"
      pattern: "seedPendingMutation.*operation.*delete"
    - from: "ResurrectionPreventionTests.swift"
      to: "MockDataStore.upsertEventCalls"
      via: "spy verification that upsert was NOT called"
      pattern: "upsertEventCalls.*isEmpty"
---

<objective>
Create unit tests verifying resurrection prevention in SyncEngine: deleted items don't reappear during pullChanges, pendingDeleteIds is populated before sync, both in-memory and SwiftData fallback paths work, cursor advances correctly, and pendingDeleteIds clears after successful delete sync.

Purpose: Cover all 5 RES requirements (RES-01 through RES-05) to ensure deleted items stay deleted even when server's change_log contains CREATE entries for them.

Output: ResurrectionPreventionTests.swift with 8-10 tests organized in 3-4 @Suite groups
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-unit-tests-resurrection-prevention/18-CONTEXT.md
@.planning/phases/18-unit-tests-resurrection-prevention/18-RESEARCH.md
@.planning/phases/17-unit-tests-circuit-breaker/17-01-SUMMARY.md

# Source files for understanding resurrection prevention implementation
@apps/ios/trendy/Services/Sync/SyncEngine.swift (lines 88-163, 207-218, 330-348, 1331-1351, 1508-1521)

# Test infrastructure
@apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift
@apps/ios/trendyTests/Mocks/MockDataStore.swift
@apps/ios/trendyTests/Mocks/MockNetworkClient.swift
@apps/ios/trendyTests/TestSupport.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ResurrectionPreventionTests.swift with core resurrection tests</name>
  <files>apps/ios/trendyTests/SyncEngine/ResurrectionPreventionTests.swift</files>
  <action>
Create ResurrectionPreventionTests.swift in the SyncEngine test directory.

**File structure:**
1. Header comment documenting requirements tested (RES-01 through RES-05)
2. Import statements (Testing, Foundation, @testable import trendy)
3. Reusable test helpers (reuse makeTestDependencies pattern from CircuitBreakerTests)
4. 3-4 @Suite groups organized by behavior

**Helper functions to include:**
- `makeTestDependencies()` - Same pattern as CircuitBreakerTests: returns (mockNetwork, mockStore, factory, engine) tuple
- `configureForPullChanges(mockNetwork:mockStore:)` - Sets up health check pass, non-zero cursor (1000), and empty base change feed
- `seedDeleteMutation(mockStore:entityId:entityType:)` - Seeds a DELETE pending mutation for an entity

**Test Suites and Tests:**

**@Suite("Resurrection Prevention - Skip Deleted Items")**

Test 1: `deletedItemsNotRecreatedDuringPullChanges` (RES-01)
- Seed DELETE mutation for "evt-deleted"
- Set cursor to non-zero (1000) to trigger pullChanges path
- Configure change feed with CREATE entry for "evt-deleted"
- Call performSync()
- Assert: mockStore.upsertEventCalls is empty (entity was NOT upserted)

Test 2: `multipleDeletedItemsAllSkipped` (RES-02, RES-03)
- Seed DELETE mutations for 3 entities: "evt-1", "evt-2", "evt-3"
- Configure change feed with CREATE entries for all 3
- Call performSync()
- Assert: mockStore.upsertEventCalls is empty for all 3

Test 3: `mixedDeleteAndNonDeleteItemsHandledCorrectly`
- Seed DELETE mutation for "evt-deleted"
- Configure change feed with CREATE for "evt-deleted" AND CREATE for "evt-new"
- Call performSync()
- Assert: mockStore.upsertEventCalls has exactly 1 call for "evt-new"
- Assert: "evt-deleted" was NOT upserted

**@Suite("Resurrection Prevention - pendingDeleteIds Population")**

Test 4: `pendingDeleteIdsPopulatedBeforePullChanges` (RES-02)
- This tests the behavior that pendingDeleteIds is populated BEFORE processing changes
- Seed DELETE mutations, configure resurrect-triggering change feed
- Verify resurrection prevention worked (proves population happened before processing)

Test 5: `swiftDataFallbackPathPreventsResurrection`
- Test the hasPendingDeleteInSwiftData fallback path
- This is harder to test directly since pendingDeleteIds is always populated
- However, the test for RES-01/RES-02 implicitly covers this since both paths are checked

**@Suite("Resurrection Prevention - Cursor and Cleanup")**

Test 6: `cursorAdvancesAfterPullChanges` (RES-04)
- Set initial cursor to 1000
- Configure change feed with nextCursor: 2000, hasMore: false
- Call performSync()
- Assert: UserDefaults cursor key has value 2000

Test 7: `cursorAdvancesWithPendingDeletes` (RES-04)
- Seed DELETE mutation
- Configure change feed with nextCursor: 2000
- Also configure successful batch delete response for the mutation flush
- Call performSync()
- Assert: Cursor advanced to 2000

Test 8: `pendingDeleteIdsClearedAfterSuccessfulSync` (RES-05)
- Seed DELETE mutation for "evt-1"
- Configure successful sync (flush succeeds, pullChanges succeeds)
- Call performSync() first time
- Clear mocks, seed same mutation again
- Configure change feed with CREATE for "evt-1"
- Call performSync() second time
- Assert: This time "evt-1" IS created (because first sync cleared pendingDeleteIds)

**@Suite("Resurrection Prevention - Entity Types")**

Test 9: `eventTypeDeletionPreventedFromResurrection`
- Seed DELETE mutation for event_type entity
- Configure change feed with CREATE for that event_type
- Assert: Event type was NOT upserted

Test 10: `geofenceDeletionPreventedFromResurrection`
- Seed DELETE mutation for geofence entity
- Configure change feed with CREATE for that geofence
- Assert: Geofence was NOT upserted

**Key implementation notes:**
- Always set cursor to non-zero (e.g., 1000) before tests to trigger pullChanges path (not bootstrap)
- Always configure health check pass: `mockNetwork.getEventTypesResponses = [.success([APIModelFixture.makeAPIEventType()])]`
- For change feed entries, use `APIModelFixture.makeChangeEntry()` with appropriate parameters
- For DELETE mutations, use `mockStore.seedPendingMutation(entityType: .event, entityId: "...", operation: .delete, payload: Data())`
- Verify resurrection prevention by checking that upsertEventCalls/upsertEventTypeCalls/upsertGeofenceCalls is empty
- Use cursor key pattern: `"sync_engine_cursor_\(AppEnvironment.current.rawValue)"`
- Use UserDefaults.standard.set() and UserDefaults.standard.integer() for cursor manipulation/verification
  </action>
  <verify>
Run Swift syntax validation:
```bash
cd /Users/cipher/Repositories/trendy/apps/ios && swift -parse trendyTests/SyncEngine/ResurrectionPreventionTests.swift 2>&1 | head -50
```
If parsing fails, check imports and ensure all types are available from @testable import trendy.
  </verify>
  <done>
ResurrectionPreventionTests.swift exists with 8-10 tests covering all 5 RES requirements, organized in 3-4 @Suite groups, following CircuitBreakerTests.swift patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ChangeEntryData fixture helper if needed</name>
  <files>apps/ios/trendyTests/TestSupport.swift</files>
  <action>
If Task 1 requires creating ChangeEntry instances with data for resurrection tests, extend APIModelFixture in TestSupport.swift with a helper to create ChangeEntryData.

**Check if needed:**
First, check if makeChangeEntry with nil data is sufficient for resurrection tests. The resurrection check in SyncEngine.applyUpsert happens BEFORE accessing change.data, so nil data is acceptable for testing the skip logic.

**If ChangeEntryData helper is needed:**
Add to APIModelFixture struct:

```swift
/// Create a ChangeEntryData for event changes
static func makeChangeEntryData(
    eventTypeId: String = "type-1",
    timestamp: Date = Date(timeIntervalSince1970: 1704067200),
    notes: String? = nil
) -> ChangeEntryData {
    // ChangeEntryData uses custom decoder, create via JSON roundtrip
    let json: [String: Any] = [
        "event_type_id": eventTypeId,
        "timestamp": ISO8601DateFormatter().string(from: timestamp),
        "notes": notes as Any
    ].compactMapValues { $0 }
    let data = try! JSONSerialization.data(withJSONObject: json)
    return try! JSONDecoder().decode(ChangeEntryData.self, from: data)
}
```

**Decision:** Only add this if resurrection tests fail without it. The resurrection prevention check happens at the entityId level before any data processing, so nil data in ChangeEntry should be sufficient.
  </action>
  <verify>
If TestSupport.swift was modified, validate syntax:
```bash
cd /Users/cipher/Repositories/trendy/apps/ios && swift -parse trendyTests/TestSupport.swift 2>&1 | head -20
```
  </verify>
  <done>
Either: TestSupport.swift extended with makeChangeEntryData helper, OR confirmed that existing fixtures are sufficient for resurrection tests (no changes needed).
  </done>
</task>

</tasks>

<verification>
1. ResurrectionPreventionTests.swift exists in SyncEngine test directory
2. File has valid Swift syntax (swift -parse succeeds)
3. All 5 RES requirements have corresponding test coverage:
   - RES-01: Tests 1, 2, 3 (deleted items not re-created)
   - RES-02: Tests 2, 4 (pendingDeleteIds populated before pull)
   - RES-03: Tests 2, 3, 9, 10 (bootstrap/pullChanges skips pendingDeleteIds)
   - RES-04: Tests 6, 7 (cursor advances after delete sync)
   - RES-05: Test 8 (pendingDeleteIds cleared after confirm)
4. Test patterns match CircuitBreakerTests.swift (consistent helper structure)
5. Tests compile (syntax validates)
</verification>

<success_criteria>
- ResurrectionPreventionTests.swift has 8-10 @Test functions
- Tests organized in 3-4 @Suite groups by behavior category
- All 5 RES requirements covered with explicit test mapping
- Uses established patterns: makeTestDependencies, seedPendingMutation, response queues
- Swift syntax validates successfully
- Commit created with atomic test file addition
</success_criteria>

<output>
After completion, create `.planning/phases/18-unit-tests-resurrection-prevention/18-01-SUMMARY.md`
</output>
