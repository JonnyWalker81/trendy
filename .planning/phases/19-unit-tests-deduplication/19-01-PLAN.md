---
phase: 19-unit-tests-deduplication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendyTests/SyncEngine/DeduplicationTests.swift
  - apps/ios/trendyTests/Mocks/MockNetworkClient.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Test verifies queue-level deduplication prevents duplicate pending mutations"
    - "Test verifies each PendingMutation has unique clientRequestId (idempotency key)"
    - "Test verifies same idempotency key reused on retry after network error"
    - "Test verifies 409 Conflict triggers local duplicate deletion"
    - "Test verifies non-409 errors do not trigger deduplication behavior"
  artifacts:
    - path: "apps/ios/trendyTests/SyncEngine/DeduplicationTests.swift"
      provides: "Deduplication unit tests covering DUP-01 through DUP-05"
      min_lines: 300
    - path: "apps/ios/trendyTests/Mocks/MockNetworkClient.swift"
      provides: "Extended with response queue for createEventWithIdempotency"
      contains: "createEventWithIdempotencyResponses"
  key_links:
    - from: "DeduplicationTests.swift"
      to: "SyncEngine"
      via: "makeTestDependencies helper"
      pattern: "let engine = SyncEngine\\("
    - from: "DeduplicationTests.swift"
      to: "MockNetworkClient"
      via: "spy pattern verification"
      pattern: "createEventWithIdempotencyCalls"
    - from: "DeduplicationTests.swift"
      to: "MockDataStore"
      via: "hasPendingMutation verification"
      pattern: "hasPendingMutationCalls"
---

<objective>
Create unit tests verifying SyncEngine deduplication mechanisms: queue-level prevention of duplicate pending mutations, idempotency key uniqueness and reuse, 409 Conflict handling, and error discrimination.

Purpose: Validate the two-layer deduplication system that prevents duplicate event creation during sync operations. The queue layer (hasPendingMutation) prevents redundant mutations from being queued, while the API layer (idempotency keys) ensures exactly-once semantics on the network.

Output:
- DeduplicationTests.swift with 8-10 tests covering DUP-01 through DUP-05
- Extended MockNetworkClient with createEventWithIdempotencyResponses queue for retry testing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-unit-tests-deduplication/19-CONTEXT.md
@.planning/phases/19-unit-tests-deduplication/19-RESEARCH.md

# Prior test patterns to follow
@apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift
@apps/ios/trendyTests/SyncEngine/ResurrectionPreventionTests.swift

# SyncEngine deduplication implementation
@apps/ios/trendy/Services/Sync/SyncEngine.swift (lines 520-558 queueMutation, 837-855 isDuplicateError handling, 1122-1159 flushCreate with idempotency)

# PendingMutation model (clientRequestId generation)
@apps/ios/trendy/Models/PendingMutation.swift

# APIError.isDuplicateError
@apps/ios/trendy/Services/APIClient.swift (lines 639-651)

# Mock infrastructure
@apps/ios/trendyTests/Mocks/MockNetworkClient.swift
@apps/ios/trendyTests/Mocks/MockDataStore.swift
@apps/ios/trendyTests/TestSupport.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend MockNetworkClient with response queue for createEventWithIdempotency</name>
  <files>apps/ios/trendyTests/Mocks/MockNetworkClient.swift</files>
  <action>
Extend MockNetworkClient.swift to support response queues for `createEventWithIdempotency`. This is needed for testing retry scenarios where the first call fails and second succeeds.

**Add response queue array (near line 211, with other response queues):**

```swift
var createEventWithIdempotencyResponses: [Result<APIEvent, Error>] = []
```

**Modify createEventWithIdempotency method (around line 460) to use response queue:**

Replace the current implementation:
```swift
func createEventWithIdempotency(_ request: CreateEventRequest, idempotencyKey: String) async throws -> APIEvent {
    lock.lock()
    createEventWithIdempotencyCalls.append(CreateEventWithIdempotencyCall(request: request, idempotencyKey: idempotencyKey, timestamp: Date()))

    // Check response queue first (for sequential testing)
    if !createEventWithIdempotencyResponses.isEmpty {
        let result = createEventWithIdempotencyResponses.removeFirst()
        lock.unlock()
        switch result {
        case .success(let event): return event
        case .failure(let error): throw error
        }
    }
    lock.unlock()

    // Check global error
    if let error = errorToThrow {
        throw error
    }

    return APIEvent(
        id: request.id,
        userId: "user-1",
        eventTypeId: request.eventTypeId,
        timestamp: request.timestamp,
        notes: request.notes,
        isAllDay: request.isAllDay,
        endDate: request.endDate,
        sourceType: request.sourceType,
        externalId: request.externalId,
        originalTitle: request.originalTitle,
        geofenceId: request.geofenceId,
        locationLatitude: request.locationLatitude,
        locationLongitude: request.locationLongitude,
        locationName: request.locationName,
        healthKitSampleId: request.healthKitSampleId,
        healthKitCategory: request.healthKitCategory,
        properties: request.properties,
        createdAt: Date(),
        updatedAt: Date(),
        eventType: nil
    )
}
```

**Add to reset() method (around line 948):**

```swift
createEventWithIdempotencyResponses.removeAll()
```

This follows the same pattern used for other methods like `createEventsBatchResponses`.
  </action>
  <verify>
Verify MockNetworkClient compiles with the new response queue:
```bash
cd /Users/cipher/Repositories/trendy/apps/ios && swift -parse trendyTests/Mocks/MockNetworkClient.swift 2>&1 | head -20 || echo "Parse check complete"
```
  </verify>
  <done>
MockNetworkClient.swift extended with createEventWithIdempotencyResponses array and modified createEventWithIdempotency to check queue first, enabling retry scenario testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DeduplicationTests.swift with comprehensive test coverage</name>
  <files>apps/ios/trendyTests/SyncEngine/DeduplicationTests.swift</files>
  <action>
Create `apps/ios/trendyTests/SyncEngine/DeduplicationTests.swift` with tests covering all 5 DUP requirements.

**File Structure:**

```swift
//
//  DeduplicationTests.swift
//  trendyTests
//
//  Unit tests for SyncEngine deduplication mechanisms.
//  Tests queue-level prevention and API-level idempotency keys.
//
//  Requirements tested:
//  - DUP-01: Test same event not created twice with same idempotency key
//  - DUP-02: Test retry after network error reuses same idempotency key
//  - DUP-03: Test different mutations use different idempotency keys
//  - DUP-04: Test server 409 Conflict response handled correctly
//  - DUP-05: Test mutation queue prevents duplicate pending entries
//

import Testing
import Foundation
@testable import trendy

// MARK: - Test Helpers

/// Helper to create fresh test dependencies for each test
private func makeTestDependencies() -> (mockNetwork: MockNetworkClient, mockStore: MockDataStore, factory: MockDataStoreFactory, engine: SyncEngine) {
    let mockNetwork = MockNetworkClient()
    let mockStore = MockDataStore()
    let factory = MockDataStoreFactory(mockStore: mockStore)
    let engine = SyncEngine(networkClient: mockNetwork, dataStoreFactory: factory)
    return (mockNetwork, mockStore, factory, engine)
}

/// Helper to configure mock for flush operations (skip bootstrap, pass health check)
private func configureForFlush(mockNetwork: MockNetworkClient, mockStore: MockDataStore) {
    // Health check passes (required before any sync operations)
    mockNetwork.getEventTypesResponses = [.success([APIModelFixture.makeAPIEventType()])]

    // Set cursor to non-zero to skip bootstrap
    UserDefaults.standard.set(1000, forKey: "sync_engine_cursor_\(AppEnvironment.current.rawValue)")

    // Configure empty change feed to skip pullChanges processing
    mockNetwork.changeFeedResponseToReturn = ChangeFeedResponse(changes: [], nextCursor: 1000, hasMore: false)
}

/// Helper to seed a CREATE pending mutation for an event
private func seedCreateMutation(mockStore: MockDataStore, eventId: String, eventTypeId: String = "type-1") -> PendingMutation {
    let request = APIModelFixture.makeCreateEventRequest(id: eventId, eventTypeId: eventTypeId)
    let payload = try! JSONEncoder().encode(request)
    return mockStore.seedPendingMutation(entityType: .event, entityId: eventId, operation: .create, payload: payload)
}

/// Helper to seed an Event in MockDataStore for deletion tests
private func seedEvent(mockStore: MockDataStore, id: String, eventTypeId: String = "type-1") {
    // Seed an event type first
    _ = mockStore.seedEventType { type in
        type.id = eventTypeId
        type.name = "Test Type"
    }
    // Then seed the event
    if let eventType = mockStore.storedEventTypes[eventTypeId] {
        _ = mockStore.seedEvent(eventType: eventType) { event in
            event.id = id
        }
    }
}

// MARK: - Queue Level Deduplication

@Suite("Queue Level Deduplication")
struct QueueDeduplicationTests {

    @Test("Mutation queue prevents duplicate pending entries (DUP-05)")
    func queuePreventsDuplicateEntries() async throws {
        let (mockNetwork, mockStore, _, engine) = makeTestDependencies()

        // Queue first mutation
        let request = APIModelFixture.makeCreateEventRequest(id: "evt-1", eventTypeId: "type-1")
        let payload = try JSONEncoder().encode(request)

        try await engine.queueMutation(entityType: .event, operation: .create, entityId: "evt-1", payload: payload)

        // Attempt to queue duplicate (same entityId + entityType + operation)
        try await engine.queueMutation(entityType: .event, operation: .create, entityId: "evt-1", payload: payload)

        // Verify only one pending mutation exists
        let pending = try mockStore.fetchPendingMutations()
        #expect(pending.count == 1, "Duplicate mutation should be skipped - got \(pending.count)")
    }

    @Test("Queue allows different operations for same entity")
    func queueAllowsDifferentOperationsForSameEntity() async throws {
        let (_, mockStore, _, engine) = makeTestDependencies()

        // Queue CREATE
        let createRequest = APIModelFixture.makeCreateEventRequest(id: "evt-1", eventTypeId: "type-1")
        let createPayload = try JSONEncoder().encode(createRequest)
        try await engine.queueMutation(entityType: .event, operation: .create, entityId: "evt-1", payload: createPayload)

        // Queue DELETE for same entity (different operation)
        try await engine.queueMutation(entityType: .event, operation: .delete, entityId: "evt-1", payload: Data())

        // Both should be queued
        let pending = try mockStore.fetchPendingMutations()
        #expect(pending.count == 2, "Different operations should both be queued")
    }

    @Test("Queue allows same operation for different entities")
    func queueAllowsSameOperationForDifferentEntities() async throws {
        let (_, mockStore, _, engine) = makeTestDependencies()

        // Queue CREATE for evt-1
        let request1 = APIModelFixture.makeCreateEventRequest(id: "evt-1", eventTypeId: "type-1")
        let payload1 = try JSONEncoder().encode(request1)
        try await engine.queueMutation(entityType: .event, operation: .create, entityId: "evt-1", payload: payload1)

        // Queue CREATE for evt-2
        let request2 = APIModelFixture.makeCreateEventRequest(id: "evt-2", eventTypeId: "type-1")
        let payload2 = try JSONEncoder().encode(request2)
        try await engine.queueMutation(entityType: .event, operation: .create, entityId: "evt-2", payload: payload2)

        // Both should be queued
        let pending = try mockStore.fetchPendingMutations()
        #expect(pending.count == 2, "Different entities should both be queued")
    }
}

// MARK: - Idempotency Key Uniqueness

@Suite("Idempotency Key Uniqueness")
struct IdempotencyKeyUniquenessTests {

    @Test("Different mutations have different idempotency keys (DUP-03)")
    func differentMutationsHaveDifferentKeys() async throws {
        let (_, mockStore, _, _) = makeTestDependencies()

        // Seed two different mutations
        let mutation1 = seedCreateMutation(mockStore: mockStore, eventId: "evt-1")
        let mutation2 = seedCreateMutation(mockStore: mockStore, eventId: "evt-2")

        // Verify keys are unique
        #expect(mutation1.clientRequestId != mutation2.clientRequestId,
                "Each mutation must have unique idempotency key")
    }

    @Test("Idempotency key is UUID format")
    func idempotencyKeyIsUUIDFormat() async throws {
        let (_, mockStore, _, _) = makeTestDependencies()

        let mutation = seedCreateMutation(mockStore: mockStore, eventId: "evt-1")

        // Verify key is valid UUID
        let uuid = UUID(uuidString: mutation.clientRequestId)
        #expect(uuid != nil, "clientRequestId should be valid UUID - got: \(mutation.clientRequestId)")
    }

    @Test("Same event not created twice with same idempotency key (DUP-01)")
    func sameEventNotCreatedTwiceWithSameKey() async throws {
        let (mockNetwork, mockStore, _, engine) = makeTestDependencies()

        // Configure for successful sync
        configureForFlush(mockNetwork: mockNetwork, mockStore: mockStore)

        // Configure success response
        mockNetwork.createEventWithIdempotencyResponses = [
            .success(APIModelFixture.makeAPIEvent(id: "evt-1"))
        ]

        // Seed mutation
        let mutation = seedCreateMutation(mockStore: mockStore, eventId: "evt-1")
        let originalKey = mutation.clientRequestId

        await engine.performSync()

        // Verify idempotency key was used correctly
        #expect(mockNetwork.createEventWithIdempotencyCalls.count == 1,
                "Should have exactly one API call")
        #expect(mockNetwork.createEventWithIdempotencyCalls.first?.idempotencyKey == originalKey,
                "API call should use mutation's clientRequestId as idempotency key")
    }
}

// MARK: - Retry Behavior

@Suite("Retry Behavior")
struct RetryBehaviorTests {

    @Test("Retry after network error reuses same idempotency key (DUP-02)")
    func retryReusesSameIdempotencyKey() async throws {
        let (mockNetwork, mockStore, _, engine) = makeTestDependencies()

        // Configure for flush with extra health check responses for retry
        mockNetwork.getEventTypesResponses = [
            .success([APIModelFixture.makeAPIEventType()]),
            .success([APIModelFixture.makeAPIEventType()])
        ]
        UserDefaults.standard.set(1000, forKey: "sync_engine_cursor_\(AppEnvironment.current.rawValue)")
        mockNetwork.changeFeedResponseToReturn = ChangeFeedResponse(changes: [], nextCursor: 1000, hasMore: false)

        // Configure: first call fails with network error, second succeeds
        mockNetwork.createEventWithIdempotencyResponses = [
            .failure(APIError.networkError(NSError(domain: NSURLErrorDomain, code: NSURLErrorTimedOut, userInfo: nil))),
            .success(APIModelFixture.makeAPIEvent(id: "evt-1"))
        ]

        // Seed mutation and capture its idempotency key
        let mutation = seedCreateMutation(mockStore: mockStore, eventId: "evt-1")
        let originalKey = mutation.clientRequestId

        // First sync - will fail
        await engine.performSync()

        // Second sync - should succeed with same key
        await engine.performSync()

        // Verify both calls used the same idempotency key
        let calls = mockNetwork.createEventWithIdempotencyCalls
        #expect(calls.count == 2, "Should have two API calls (initial + retry) - got \(calls.count)")

        if calls.count >= 2 {
            #expect(calls[0].idempotencyKey == originalKey, "First call should use original key")
            #expect(calls[1].idempotencyKey == originalKey, "Retry should reuse same key")
            #expect(calls[0].idempotencyKey == calls[1].idempotencyKey, "Both calls must use identical key")
        }
    }
}

// MARK: - 409 Conflict Handling

@Suite("409 Conflict Handling")
struct ConflictHandlingTests {

    @Test("Server 409 Conflict response deletes local duplicate (DUP-04)")
    func conflict409DeletesLocalDuplicate() async throws {
        let (mockNetwork, mockStore, _, engine) = makeTestDependencies()

        // Configure for flush
        configureForFlush(mockNetwork: mockNetwork, mockStore: mockStore)

        // Configure 409 Conflict response
        mockNetwork.createEventWithIdempotencyResponses = [
            .failure(APIError.serverError("Duplicate key violation", 409))
        ]

        // Seed mutation AND local event (the duplicate)
        _ = seedCreateMutation(mockStore: mockStore, eventId: "evt-duplicate")
        seedEvent(mockStore: mockStore, id: "evt-duplicate")

        // Verify event exists before sync
        let eventsBefore = try mockStore.fetchAllEvents()
        #expect(eventsBefore.count == 1, "Event should exist before sync")

        await engine.performSync()

        // Verify mutation was removed from queue (treated as success)
        let pendingAfter = try mockStore.fetchPendingMutations()
        #expect(pendingAfter.isEmpty, "409 Conflict should remove mutation from queue")

        // Verify local duplicate was deleted
        let eventsAfter = try mockStore.fetchAllEvents()
        #expect(eventsAfter.isEmpty, "Local duplicate should be deleted on 409")
    }

    @Test("409 with unique constraint message also triggers deduplication")
    func uniqueConstraintMessageTriggersDedupe() async throws {
        let (mockNetwork, mockStore, _, engine) = makeTestDependencies()

        // Configure for flush
        configureForFlush(mockNetwork: mockNetwork, mockStore: mockStore)

        // Configure error with unique constraint message (not 409 code)
        mockNetwork.createEventWithIdempotencyResponses = [
            .failure(APIError.serverError("unique constraint violation on external_id", 400))
        ]

        // Seed mutation and local event
        _ = seedCreateMutation(mockStore: mockStore, eventId: "evt-unique")
        seedEvent(mockStore: mockStore, id: "evt-unique")

        await engine.performSync()

        // Should treat as duplicate because message contains "unique"
        let pendingAfter = try mockStore.fetchPendingMutations()
        #expect(pendingAfter.isEmpty, "Unique constraint error should remove mutation from queue")
    }

    @Test("Non-409 errors do not trigger deduplication")
    func non409ErrorsDoNotDeduplicate() async throws {
        let (mockNetwork, mockStore, _, engine) = makeTestDependencies()

        // Configure for flush
        configureForFlush(mockNetwork: mockNetwork, mockStore: mockStore)

        // Configure 400 Bad Request (not duplicate)
        mockNetwork.createEventWithIdempotencyResponses = [
            .failure(APIError.httpError(400))
        ]

        // Seed mutation
        _ = seedCreateMutation(mockStore: mockStore, eventId: "evt-1")

        await engine.performSync()

        // Verify mutation still pending (not removed as duplicate)
        let pending = try mockStore.fetchPendingMutations()
        #expect(pending.count == 1, "400 error should not trigger deduplication - got \(pending.count) pending")
        #expect(pending.first?.attempts == 1, "Should record failure attempt")
    }

    @Test("500 errors do not trigger deduplication")
    func server500DoesNotDeduplicate() async throws {
        let (mockNetwork, mockStore, _, engine) = makeTestDependencies()

        // Configure for flush
        configureForFlush(mockNetwork: mockNetwork, mockStore: mockStore)

        // Configure 500 Internal Server Error
        mockNetwork.createEventWithIdempotencyResponses = [
            .failure(APIError.serverError("Internal server error", 500))
        ]

        // Seed mutation
        _ = seedCreateMutation(mockStore: mockStore, eventId: "evt-1")

        await engine.performSync()

        // Verify mutation still pending
        let pending = try mockStore.fetchPendingMutations()
        #expect(pending.count == 1, "500 error should not trigger deduplication")
    }
}
```

**Test Matrix:**

| Requirement | Description | Test Functions |
|-------------|-------------|----------------|
| DUP-01 | Same event not created twice | `sameEventNotCreatedTwiceWithSameKey` |
| DUP-02 | Retry reuses idempotency key | `retryReusesSameIdempotencyKey` |
| DUP-03 | Different mutations different keys | `differentMutationsHaveDifferentKeys` |
| DUP-04 | 409 Conflict handled | `conflict409DeletesLocalDuplicate`, `uniqueConstraintMessageTriggersDedupe` |
| DUP-05 | Queue prevents duplicates | `queuePreventsDuplicateEntries`, `queueAllowsDifferentOperationsForSameEntity`, `queueAllowsSameOperationForDifferentEntities` |

**Edge Cases Covered:**
- Non-409 errors (400, 500) should NOT trigger deduplication
- UUID format verification for idempotency keys
- Queue allows different operations for same entity
- Queue allows same operation for different entities
  </action>
  <verify>
Verify syntax and structure of DeduplicationTests.swift:
```bash
cd /Users/cipher/Repositories/trendy/apps/ios && swift -parse trendyTests/SyncEngine/DeduplicationTests.swift 2>&1 | head -20 || echo "Parse check complete"
```
  </verify>
  <done>
DeduplicationTests.swift created with 10 tests in 4 suites covering all 5 DUP requirements: queue-level deduplication, idempotency key uniqueness, retry behavior, and 409 Conflict handling.
  </done>
</task>

</tasks>

<verification>
1. MockNetworkClient.swift has createEventWithIdempotencyResponses array
2. MockNetworkClient.createEventWithIdempotency checks response queue before errorToThrow
3. MockNetworkClient.reset() clears createEventWithIdempotencyResponses
4. DeduplicationTests.swift exists in apps/ios/trendyTests/SyncEngine/
5. DeduplicationTests.swift has 10 @Test functions in 4 @Suite groups
6. All 5 DUP requirements covered by at least one test
7. Tests follow existing patterns from CircuitBreakerTests and ResurrectionPreventionTests
8. Test files compile with Swift syntax validation
</verification>

<success_criteria>
- MockNetworkClient extended with response queue for createEventWithIdempotency
- DeduplicationTests.swift covers DUP-01 through DUP-05
- Tests verify both queue-level and API-level deduplication mechanisms
- Tests verify 409 Conflict handling deletes local duplicates
- Tests verify non-409 errors do not falsely trigger deduplication
- Tests verify idempotency key reuse on retry
- Test files compile successfully (syntax validated with swiftc -parse)
- Tests will run once FullDisclosureSDK blocker is resolved
</success_criteria>

<output>
After completion, create `.planning/phases/19-unit-tests-deduplication/19-01-SUMMARY.md`
</output>
