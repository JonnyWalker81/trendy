---
phase: 13-protocol-definitions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/Protocols/NetworkClientProtocol.swift
autonomous: true

must_haves:
  truths:
    - "NetworkClientProtocol exists and compiles"
    - "Protocol is marked Sendable for actor boundary crossing"
    - "All methods SyncEngine calls on APIClient are declared in protocol"
    - "All methods are async for actor isolation compatibility"
  artifacts:
    - path: "apps/ios/trendy/Protocols/NetworkClientProtocol.swift"
      provides: "Network abstraction protocol for SyncEngine DI"
      contains: "protocol NetworkClientProtocol: Sendable"
  key_links:
    - from: "NetworkClientProtocol"
      to: "SyncEngine"
      via: "Dependency injection (future Phase 15)"
      pattern: "protocol NetworkClientProtocol"
---

<objective>
Define NetworkClientProtocol with all network methods SyncEngine requires for backend communication.

Purpose: Enable dependency injection in SyncEngine so tests can use mock network clients instead of real APIClient. This is the first step toward unit testable sync logic.

Output: Protocols/NetworkClientProtocol.swift with complete method signatures matching SyncEngine's usage of APIClient.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-protocol-definitions/13-RESEARCH.md
@apps/ios/trendy/Services/Sync/SyncEngine.swift
@apps/ios/trendy/Services/APIClient.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Protocols directory and NetworkClientProtocol</name>
  <files>apps/ios/trendy/Protocols/NetworkClientProtocol.swift</files>
  <action>
Create new directory `apps/ios/trendy/Protocols/` if it doesn't exist.

Create `NetworkClientProtocol.swift` with the following structure:

```swift
//
//  NetworkClientProtocol.swift
//  trendy
//
//  Protocol for network operations required by SyncEngine.
//  Enables dependency injection for unit testing.
//

import Foundation

/// Protocol for network operations required by SyncEngine.
/// Conforms to Sendable for safe use across actor boundaries.
/// All methods are async as required for actor isolation.
protocol NetworkClientProtocol: Sendable {
    // MARK: - Event Type Operations
    func getEventTypes() async throws -> [APIEventType]
    func createEventType(_ request: CreateEventTypeRequest) async throws -> APIEventType
    func createEventTypeWithIdempotency(_ request: CreateEventTypeRequest, idempotencyKey: String) async throws -> APIEventType
    func updateEventType(id: String, _ request: UpdateEventTypeRequest) async throws -> APIEventType
    func deleteEventType(id: String) async throws

    // MARK: - Event Operations
    func getEvents(limit: Int, offset: Int) async throws -> [APIEvent]
    func getAllEvents(batchSize: Int) async throws -> [APIEvent]
    func createEvent(_ request: CreateEventRequest) async throws -> APIEvent
    func createEventWithIdempotency(_ request: CreateEventRequest, idempotencyKey: String) async throws -> APIEvent
    func createEventsBatch(_ events: [CreateEventRequest]) async throws -> BatchCreateEventsResponse
    func updateEvent(id: String, _ request: UpdateEventRequest) async throws -> APIEvent
    func deleteEvent(id: String) async throws

    // MARK: - Geofence Operations
    func getGeofences(activeOnly: Bool) async throws -> [APIGeofence]
    func createGeofence(_ request: CreateGeofenceRequest) async throws -> APIGeofence
    func createGeofenceWithIdempotency(_ request: CreateGeofenceRequest, idempotencyKey: String) async throws -> APIGeofence
    func updateGeofence(id: String, _ request: UpdateGeofenceRequest) async throws -> APIGeofence
    func deleteGeofence(id: String) async throws

    // MARK: - Property Definition Operations
    func getPropertyDefinitions(eventTypeId: String) async throws -> [APIPropertyDefinition]
    func createPropertyDefinition(eventTypeId: String, _ request: CreatePropertyDefinitionRequest) async throws -> APIPropertyDefinition
    func createPropertyDefinitionWithIdempotency(_ request: CreatePropertyDefinitionRequest, idempotencyKey: String) async throws -> APIPropertyDefinition
    func updatePropertyDefinition(id: String, _ request: UpdatePropertyDefinitionRequest) async throws -> APIPropertyDefinition
    func deletePropertyDefinition(id: String) async throws

    // MARK: - Change Feed Operations
    func getChanges(since cursor: Int64, limit: Int) async throws -> ChangeFeedResponse
    func getLatestCursor() async throws -> Int64
}
```

Key design decisions:
1. Protocol is Sendable - required because SyncEngine is an actor and will hold a reference to this
2. All methods are async - required for actor isolation (calling from outside actor context)
3. Method signatures match APIClient exactly - enables direct conformance without adapter
4. Default parameter values NOT included in protocol - they go in conforming types
5. No getGeofences() without parameter - callers must specify activeOnly explicitly for protocol

Note: The protocol does NOT include analytics, insights, onboarding, or health check endpoints because SyncEngine doesn't use them. Keep the protocol minimal to the actual sync use case.
  </action>
  <verify>
Build the iOS project to verify the protocol compiles:
```bash
cd apps/ios && xcodebuild -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)"
```
  </verify>
  <done>
NetworkClientProtocol.swift exists in Protocols/ directory, compiles successfully, and contains all method signatures SyncEngine requires from APIClient.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add NetworkClientProtocol.swift to Xcode project</name>
  <files>apps/ios/trendy.xcodeproj/project.pbxproj</files>
  <action>
The new file needs to be added to the Xcode project file references so it compiles.

Use the following approach:
1. First try building - Xcode may auto-discover files in the directory
2. If build fails with "No such module" or file not found, the file needs manual project addition

For manual addition, use PlistBuddy or direct project.pbxproj editing to add the file reference and build phase entry. However, modern Xcode often auto-discovers Swift files in the project directory.

If Xcode project file editing is needed:
- Add file reference to PBXGroup for trendy target
- Add to PBXBuildFile section
- Add to Sources build phase

Alternative: Create a simple Package.swift for the Protocols module (not recommended - adds complexity)

Preferred approach: Let Xcode auto-discover or use `xcodebuild` with folder references.

If auto-discovery doesn't work, open the project in Xcode and add the Protocols folder via File > Add Files to "trendy".
  </action>
  <verify>
After ensuring the file is in the project, verify full build:
```bash
cd apps/ios && xcodebuild -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20
```
Should see BUILD SUCCEEDED.
  </verify>
  <done>
NetworkClientProtocol.swift is part of the Xcode project and builds successfully with the trendy scheme.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **File exists check:**
   ```bash
   ls -la apps/ios/trendy/Protocols/NetworkClientProtocol.swift
   ```

2. **Protocol has Sendable conformance:**
   ```bash
   grep "protocol NetworkClientProtocol: Sendable" apps/ios/trendy/Protocols/NetworkClientProtocol.swift
   ```

3. **All SyncEngine-required methods present:**
   - getEventTypes, createEventType, createEventTypeWithIdempotency, updateEventType, deleteEventType
   - getEvents, getAllEvents, createEvent, createEventWithIdempotency, createEventsBatch, updateEvent, deleteEvent
   - getGeofences, createGeofence, createGeofenceWithIdempotency, updateGeofence, deleteGeofence
   - getPropertyDefinitions, createPropertyDefinition, createPropertyDefinitionWithIdempotency, updatePropertyDefinition, deletePropertyDefinition
   - getChanges, getLatestCursor

4. **iOS build succeeds:**
   ```bash
   cd apps/ios && xcodebuild -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | grep "BUILD SUCCEEDED"
   ```
</verification>

<success_criteria>
- NetworkClientProtocol.swift exists at apps/ios/trendy/Protocols/NetworkClientProtocol.swift
- Protocol is marked `Sendable`
- Protocol declares all 22 methods SyncEngine calls on APIClient
- All protocol methods are async
- iOS project builds successfully (no new errors introduced)
- Requirement TEST-01 partially satisfied (protocol defined, conformance in Phase 14)
</success_criteria>

<output>
After completion, create `.planning/phases/13-protocol-definitions/13-01-SUMMARY.md`
</output>
