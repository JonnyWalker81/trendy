---
phase: 13-protocol-definitions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/Protocols/DataStoreProtocol.swift
  - apps/ios/trendy/Protocols/DataStoreFactory.swift
autonomous: true

must_haves:
  truths:
    - "DataStoreProtocol exists and compiles"
    - "DataStoreFactory protocol exists and compiles"
    - "DataStoreFactory is marked Sendable for actor boundary crossing"
    - "DataStoreProtocol is NOT Sendable (used within actor context only)"
    - "All methods SyncEngine calls on LocalStore are declared in DataStoreProtocol"
  artifacts:
    - path: "apps/ios/trendy/Protocols/DataStoreProtocol.swift"
      provides: "Persistence abstraction protocol for SyncEngine DI"
      contains: "protocol DataStoreProtocol"
    - path: "apps/ios/trendy/Protocols/DataStoreFactory.swift"
      provides: "Factory protocol for creating DataStore instances within actor context"
      contains: "protocol DataStoreFactory: Sendable"
  key_links:
    - from: "DataStoreFactory"
      to: "SyncEngine"
      via: "Dependency injection - factory passed to actor, creates DataStore inside"
      pattern: "protocol DataStoreFactory: Sendable"
    - from: "DataStoreProtocol"
      to: "LocalStore"
      via: "Conformance (future Phase 14)"
      pattern: "protocol DataStoreProtocol"
---

<objective>
Define DataStoreProtocol and DataStoreFactory protocols for persistence operations SyncEngine requires.

Purpose: Enable dependency injection of data store into SyncEngine. The factory pattern solves the ModelContext non-Sendable problem - ModelContainer (Sendable) is injected, ModelContext is created inside the actor's isolation context.

Output: Two protocol files - DataStoreProtocol.swift with all persistence methods, DataStoreFactory.swift with factory interface.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-protocol-definitions/13-RESEARCH.md
@apps/ios/trendy/Services/Sync/SyncEngine.swift
@apps/ios/trendy/Services/Sync/LocalStore.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DataStoreProtocol</name>
  <files>apps/ios/trendy/Protocols/DataStoreProtocol.swift</files>
  <action>
Create `DataStoreProtocol.swift` in the Protocols directory (created in plan 01, or create if plan 02 runs first).

```swift
//
//  DataStoreProtocol.swift
//  trendy
//
//  Protocol for persistence operations required by SyncEngine.
//  NOT Sendable - instances are created and used entirely within actor context.
//

import Foundation

/// Protocol for persistence operations required by SyncEngine.
/// Note: This protocol is NOT Sendable because:
/// 1. DataStore instances are created inside the actor via DataStoreFactory
/// 2. They are used only within the actor's isolation context
/// 3. The underlying ModelContext is not thread-safe
protocol DataStoreProtocol {
    // MARK: - Upsert Operations

    /// Upsert an Event by ID - creates if not exists, updates if exists.
    @discardableResult
    func upsertEvent(id: String, configure: (Event) -> Void) throws -> Event

    /// Upsert an EventType by ID
    @discardableResult
    func upsertEventType(id: String, configure: (EventType) -> Void) throws -> EventType

    /// Upsert a Geofence by ID
    @discardableResult
    func upsertGeofence(id: String, configure: (Geofence) -> Void) throws -> Geofence

    /// Upsert a PropertyDefinition by ID
    @discardableResult
    func upsertPropertyDefinition(id: String, eventTypeId: String, configure: (PropertyDefinition) -> Void) throws -> PropertyDefinition

    // MARK: - Delete Operations

    /// Delete an Event by ID
    func deleteEvent(id: String) throws

    /// Delete an EventType by ID
    func deleteEventType(id: String) throws

    /// Delete a Geofence by ID
    func deleteGeofence(id: String) throws

    /// Delete a PropertyDefinition by ID
    func deletePropertyDefinition(id: String) throws

    // MARK: - Lookup Operations

    /// Find an Event by ID
    func findEvent(id: String) throws -> Event?

    /// Find an EventType by ID
    func findEventType(id: String) throws -> EventType?

    /// Find a Geofence by ID
    func findGeofence(id: String) throws -> Geofence?

    /// Find a PropertyDefinition by ID
    func findPropertyDefinition(id: String) throws -> PropertyDefinition?

    // MARK: - Pending Operations

    /// Fetch all pending mutations ordered by creation time
    func fetchPendingMutations() throws -> [PendingMutation]

    // MARK: - Sync Status Updates

    /// Mark an Event as synced
    func markEventSynced(id: String) throws

    /// Mark an EventType as synced
    func markEventTypeSynced(id: String) throws

    /// Mark a Geofence as synced
    func markGeofenceSynced(id: String) throws

    /// Mark a PropertyDefinition as synced
    func markPropertyDefinitionSynced(id: String) throws

    // MARK: - Persistence

    /// Save any pending changes to the context
    func save() throws
}
```

Key design decisions:
1. Protocol is NOT Sendable - DataStore is created within actor and never crosses boundaries
2. Methods are synchronous (not async) - they operate on ModelContext which must be synchronous
3. Closures in upsert methods receive the model directly - caller configures properties
4. Method signatures match LocalStore exactly - enables direct conformance
5. Return types use concrete model types (Event, EventType, etc.) - safe because protocol is only used inside actor
  </action>
  <verify>
Build to verify protocol compiles:
```bash
cd apps/ios && xcodebuild -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)"
```
  </verify>
  <done>
DataStoreProtocol.swift exists with all 18 method declarations matching LocalStore's interface used by SyncEngine.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DataStoreFactory protocol</name>
  <files>apps/ios/trendy/Protocols/DataStoreFactory.swift</files>
  <action>
Create `DataStoreFactory.swift` in the Protocols directory.

```swift
//
//  DataStoreFactory.swift
//  trendy
//
//  Factory protocol for creating DataStore instances within actor context.
//  Solves the ModelContext non-Sendable problem for dependency injection.
//

import Foundation
import SwiftData

/// Factory protocol for creating DataStore instances within actor context.
///
/// This pattern solves the ModelContext threading problem:
/// - ModelContainer IS Sendable (can be passed to actor)
/// - ModelContext is NOT Sendable (must be created on the thread/actor where it's used)
///
/// The factory is injected into SyncEngine, then called inside the actor
/// to create a DataStore with a fresh ModelContext bound to that actor's context.
protocol DataStoreFactory: Sendable {
    /// Creates a new DataStore with a fresh ModelContext.
    /// Called within actor isolation context to ensure ModelContext thread safety.
    ///
    /// - Returns: A DataStore instance ready for persistence operations
    func makeDataStore() -> any DataStoreProtocol
}

/// Default factory implementation using ModelContainer.
/// Production code uses this to create real LocalStore instances.
final class DefaultDataStoreFactory: DataStoreFactory, @unchecked Sendable {
    // ModelContainer is Sendable, so this is safe
    private let modelContainer: ModelContainer

    init(modelContainer: ModelContainer) {
        self.modelContainer = modelContainer
    }

    func makeDataStore() -> any DataStoreProtocol {
        let context = ModelContext(modelContainer)
        return LocalStore(modelContext: context)
    }
}
```

Key design decisions:
1. DataStoreFactory IS Sendable - it's passed INTO the actor from outside
2. Uses `any DataStoreProtocol` return type - existential allows different implementations
3. DefaultDataStoreFactory is @unchecked Sendable because:
   - It only holds ModelContainer which IS Sendable
   - The @unchecked is a workaround for Swift not automatically inferring Sendable for final classes
   - This is safe because ModelContainer is documented as thread-safe
4. makeDataStore() creates fresh ModelContext - each call creates isolated context
5. Factory pattern enables test injection - tests pass MockDataStoreFactory instead

Note: The `@unchecked Sendable` on DefaultDataStoreFactory is acceptable here because:
- ModelContainer is explicitly documented as Sendable by Apple
- The class is final (no inheritance concerns)
- No mutable state beyond the Sendable ModelContainer
  </action>
  <verify>
Build to verify both protocols and factory compile:
```bash
cd apps/ios && xcodebuild -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | grep -E "(error:|BUILD SUCCEEDED|BUILD FAILED)"
```
  </verify>
  <done>
DataStoreFactory.swift exists with:
- DataStoreFactory protocol marked Sendable
- DefaultDataStoreFactory implementation that creates LocalStore instances
- Factory pattern enabling test injection
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify all protocol files are in Xcode project</name>
  <files>apps/ios/trendy.xcodeproj/project.pbxproj</files>
  <action>
Ensure all three protocol files are part of the Xcode project:
- NetworkClientProtocol.swift (from plan 01)
- DataStoreProtocol.swift
- DataStoreFactory.swift

Build the full project to verify:
1. All files compile
2. No duplicate symbol errors
3. No missing type errors

If files are not automatically discovered:
- The Protocols folder may need to be added as a group in the project
- Use Xcode's "Add Files" functionality or ensure the folder is within the project's file references

Most likely the files will be auto-discovered since they're in the trendy/ source directory.
  </action>
  <verify>
Full build with all protocol files:
```bash
cd apps/ios && xcodebuild -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -30
```

Also verify file existence:
```bash
ls -la apps/ios/trendy/Protocols/
```

Expected output: 3 Swift files (NetworkClientProtocol.swift, DataStoreProtocol.swift, DataStoreFactory.swift)
  </verify>
  <done>
All protocol files exist in apps/ios/trendy/Protocols/ and iOS project builds successfully with no errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Files exist check:**
   ```bash
   ls -la apps/ios/trendy/Protocols/
   ```
   Should show: DataStoreProtocol.swift, DataStoreFactory.swift (and NetworkClientProtocol.swift from plan 01)

2. **DataStoreProtocol NOT Sendable:**
   ```bash
   grep "protocol DataStoreProtocol" apps/ios/trendy/Protocols/DataStoreProtocol.swift
   ```
   Should NOT include `: Sendable`

3. **DataStoreFactory IS Sendable:**
   ```bash
   grep "protocol DataStoreFactory: Sendable" apps/ios/trendy/Protocols/DataStoreFactory.swift
   ```

4. **All LocalStore methods in protocol:**
   - upsertEvent, upsertEventType, upsertGeofence, upsertPropertyDefinition (4)
   - deleteEvent, deleteEventType, deleteGeofence, deletePropertyDefinition (4)
   - findEvent, findEventType, findGeofence, findPropertyDefinition (4)
   - fetchPendingMutations (1)
   - markEventSynced, markEventTypeSynced, markGeofenceSynced, markPropertyDefinitionSynced (4)
   - save (1)
   Total: 18 methods

5. **iOS build succeeds:**
   ```bash
   cd apps/ios && xcodebuild -scheme trendy -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | grep "BUILD SUCCEEDED"
   ```
</verification>

<success_criteria>
- DataStoreProtocol.swift exists with all 18 LocalStore methods SyncEngine uses
- DataStoreFactory.swift exists with Sendable conformance
- DefaultDataStoreFactory implementation compiles and returns LocalStore
- DataStoreProtocol is NOT Sendable (verified by grep)
- DataStoreFactory IS Sendable (verified by grep)
- iOS project builds successfully
- Requirements TEST-02 and TEST-03 partially satisfied (protocols defined, conformance in Phase 14)
</success_criteria>

<output>
After completion, create `.planning/phases/13-protocol-definitions/13-02-SUMMARY.md`
</output>
