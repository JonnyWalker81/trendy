---
phase: 06-server-api
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/internal/models/models.go
  - apps/backend/internal/handlers/event.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Validation errors aggregate all field errors in single response"
    - "Type parsing errors (timestamp, boolean) are collected not failed-fast"
    - "Response includes errors array with field, message, and code for each failure"
  artifacts:
    - path: "apps/backend/internal/models/models.go"
      provides: "RawCreateEventRequest with string fields for manual parsing"
      contains: "RawCreateEventRequest"
    - path: "apps/backend/internal/handlers/event.go"
      provides: "Aggregated validation with manual field parsing"
      contains: "NewValidationError"
  key_links:
    - from: "apps/backend/internal/handlers/event.go"
      to: "apps/backend/internal/apierror/response.go"
      via: "NewValidationError with []FieldError"
      pattern: "apierror\\.NewValidationError.*\\[\\]apierror\\.FieldError"
---

<objective>
Implement aggregated validation for CreateEvent that collects all field errors before returning.

Purpose: Close UAT gap - current ShouldBindJSON fails on first JSON unmarshal error (e.g., invalid timestamp format) before gin's validator runs, preventing error aggregation.

Output: CreateEvent handler that parses raw JSON, validates each field, collects all errors, and returns them in a single RFC 9457 response with errors array.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/backend/internal/models/models.go
@apps/backend/internal/handlers/event.go
@apps/backend/internal/apierror/response.go
@apps/backend/internal/apierror/problem.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RawCreateEventRequest model</name>
  <files>apps/backend/internal/models/models.go</files>
  <action>
Add a new struct after CreateEventRequest (around line 66) that uses string/interface{} for fields that need parsing:

```go
// RawCreateEventRequest is used for manual parsing to enable aggregated validation.
// Fields that require type conversion use string/interface{} to defer parsing.
type RawCreateEventRequest struct {
	ID                *string                  `json:"id,omitempty"`
	EventTypeID       string                   `json:"event_type_id"`
	Timestamp         string                   `json:"timestamp"`         // RFC3339 string, parsed manually
	Notes             *string                  `json:"notes"`
	IsAllDay          interface{}              `json:"is_all_day"`        // bool or string, parsed manually
	EndDate           *string                  `json:"end_date"`          // RFC3339 string, parsed manually
	SourceType        string                   `json:"source_type"`
	ExternalID        *string                  `json:"external_id"`
	OriginalTitle     *string                  `json:"original_title"`
	GeofenceID        *string                  `json:"geofence_id"`
	LocationLatitude  *float64                 `json:"location_latitude"`
	LocationLongitude *float64                 `json:"location_longitude"`
	LocationName      *string                  `json:"location_name"`
	HealthKitSampleID *string                  `json:"healthkit_sample_id,omitempty"`
	HealthKitCategory *string                  `json:"healthkit_category,omitempty"`
	Properties        map[string]PropertyValue `json:"properties,omitempty"`
}
```

Key differences from CreateEventRequest:
- Timestamp: time.Time -> string (parse manually)
- IsAllDay: bool -> interface{} (could be bool, string, or missing)
- EndDate: *time.Time -> *string (parse manually)
  </action>
  <verify>
`cd apps/backend && go build ./...` compiles without errors
  </verify>
  <done>
RawCreateEventRequest struct exists in models.go with string fields for timestamp and end_date
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement aggregated validation in CreateEvent handler</name>
  <files>apps/backend/internal/handlers/event.go</files>
  <action>
Replace the CreateEvent handler's validation logic (lines 36-41) with manual parsing that aggregates errors:

1. Change to bind RawCreateEventRequest instead:
   ```go
   var raw models.RawCreateEventRequest
   if err := c.ShouldBindJSON(&raw); err != nil {
       // JSON syntax error (not field-level)
       requestID := apierror.GetRequestID(c)
       apierror.WriteProblem(c, apierror.NewBadRequestError(requestID, err.Error(), "Invalid JSON format"))
       return
   }
   ```

2. Add validation logic after binding:
   ```go
   var fieldErrors []apierror.FieldError
   var req models.CreateEventRequest

   // Validate required fields
   if raw.EventTypeID == "" {
       fieldErrors = append(fieldErrors, apierror.FieldError{
           Field:   "event_type_id",
           Message: "is required",
           Code:    "required",
       })
   } else {
       req.EventTypeID = raw.EventTypeID
   }

   // Parse and validate timestamp (required)
   if raw.Timestamp == "" {
       fieldErrors = append(fieldErrors, apierror.FieldError{
           Field:   "timestamp",
           Message: "is required",
           Code:    "required",
       })
   } else {
       ts, err := time.Parse(time.RFC3339, raw.Timestamp)
       if err != nil {
           fieldErrors = append(fieldErrors, apierror.FieldError{
               Field:   "timestamp",
               Message: "must be a valid RFC3339 timestamp",
               Code:    "invalid_format",
           })
       } else {
           req.Timestamp = ts
       }
   }

   // Parse is_all_day (optional, defaults to false)
   if raw.IsAllDay != nil {
       switch v := raw.IsAllDay.(type) {
       case bool:
           req.IsAllDay = v
       case string:
           b, err := strconv.ParseBool(v)
           if err != nil {
               fieldErrors = append(fieldErrors, apierror.FieldError{
                   Field:   "is_all_day",
                   Message: "must be a boolean value",
                   Code:    "invalid_type",
               })
           } else {
               req.IsAllDay = b
           }
       default:
           fieldErrors = append(fieldErrors, apierror.FieldError{
               Field:   "is_all_day",
               Message: "must be a boolean value",
               Code:    "invalid_type",
           })
       }
   }

   // Parse end_date (optional)
   if raw.EndDate != nil && *raw.EndDate != "" {
       ed, err := time.Parse(time.RFC3339, *raw.EndDate)
       if err != nil {
           fieldErrors = append(fieldErrors, apierror.FieldError{
               Field:   "end_date",
               Message: "must be a valid RFC3339 timestamp",
               Code:    "invalid_format",
           })
       } else {
           req.EndDate = &ed
       }
   }

   // Copy remaining fields
   req.ID = raw.ID
   req.Notes = raw.Notes
   req.SourceType = raw.SourceType
   req.ExternalID = raw.ExternalID
   req.OriginalTitle = raw.OriginalTitle
   req.GeofenceID = raw.GeofenceID
   req.LocationLatitude = raw.LocationLatitude
   req.LocationLongitude = raw.LocationLongitude
   req.LocationName = raw.LocationName
   req.HealthKitSampleID = raw.HealthKitSampleID
   req.HealthKitCategory = raw.HealthKitCategory
   req.Properties = raw.Properties

   // Return aggregated errors if any
   if len(fieldErrors) > 0 {
       requestID := apierror.GetRequestID(c)
       apierror.WriteProblem(c, apierror.NewValidationError(requestID, fieldErrors))
       return
   }
   ```

3. Keep the rest of the handler unchanged (service call, UUID validation, response).

Note: Ensure `strconv` is imported at top of file.
  </action>
  <verify>
1. `cd apps/backend && go build ./...` compiles without errors
2. `cd apps/backend && go test ./internal/handlers/...` passes
3. Manual verification:
   ```bash
   # Start backend
   just dev-backend

   # Get a valid token (use existing auth flow or test user)

   # Test with multiple invalid fields
   curl -i -X POST http://localhost:8080/api/v1/events \
     -H "Authorization: Bearer $TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"timestamp": "not-a-date", "is_all_day": "maybe", "end_date": "also-invalid"}'

   # Should return 400 with errors array containing all three failures:
   # {
   #   "type": "urn:trendy:error:validation",
   #   "title": "Validation Error",
   #   "status": 400,
   #   "errors": [
   #     {"field": "event_type_id", "message": "is required", "code": "required"},
   #     {"field": "timestamp", "message": "must be a valid RFC3339 timestamp", "code": "invalid_format"},
   #     {"field": "is_all_day", "message": "must be a boolean value", "code": "invalid_type"},
   #     {"field": "end_date", "message": "must be a valid RFC3339 timestamp", "code": "invalid_format"}
   #   ]
   # }
   ```
  </verify>
  <done>
CreateEvent returns aggregated validation errors with all field failures in a single response
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `cd apps/backend && go build ./...`
2. Tests pass: `cd apps/backend && go test ./...`
3. Multiple validation errors are returned in single response
4. Errors array contains field, message, and code for each failure
</verification>

<success_criteria>
- RawCreateEventRequest model exists with string fields for dates
- CreateEvent aggregates all validation errors
- Response uses RFC 9457 format with errors array
- Valid requests still work correctly
- Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-server-api/06-05-SUMMARY.md`
</output>
