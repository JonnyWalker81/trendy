---
phase: 06-server-api
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/backend/internal/service/sync.go
  - apps/backend/internal/service/interfaces.go
  - apps/backend/internal/handlers/sync.go
  - apps/backend/cmd/trendy-api/serve.go
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/me/sync returns comprehensive sync status"
    - "Sync status includes event and event_type counts"
    - "Sync status includes HealthKit-specific section"
    - "Sync status includes latest change_log cursor"
    - "Status field provides sync health recommendation"
  artifacts:
    - path: "apps/backend/internal/service/sync.go"
      provides: "SyncService implementation"
      exports: ["SyncStatus", "SyncCounts", "HealthKitStatus"]
    - path: "apps/backend/internal/service/interfaces.go"
      provides: "SyncService interface"
      contains: "type SyncService interface"
    - path: "apps/backend/internal/handlers/sync.go"
      provides: "GET /api/v1/me/sync handler"
      exports: ["SyncHandler", "GetSyncStatus"]
  key_links:
    - from: "apps/backend/internal/service/sync.go"
      to: "apps/backend/internal/repository"
      via: "repository queries for counts and timestamps"
      pattern: "eventRepo\\.|eventTypeRepo\\.|changeLogRepo\\."
    - from: "apps/backend/internal/handlers/sync.go"
      to: "apps/backend/internal/service"
      via: "SyncService.GetSyncStatus call"
      pattern: "syncService\\.GetSyncStatus"
    - from: "apps/backend/cmd/trendy-api/serve.go"
      to: "/api/v1/me/sync"
      via: "route registration"
      pattern: "GET.*me/sync"
---

<objective>
Create sync status endpoint for client health checks and debugging.

Purpose: Provide clients with comprehensive sync state information including counts, timestamps, and recommendations. This supports both production UI indicators and debugging workflows.

Output: New SyncService and handler with GET /api/v1/me/sync endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-server-api/06-CONTEXT.md
@.planning/phases/06-server-api/06-RESEARCH.md

# Prior plan context
@.planning/phases/06-server-api/06-01-SUMMARY.md

# Existing code
@apps/backend/internal/repository/changelog.go (has GetLatestCursor)
@apps/backend/internal/repository/interfaces.go
@apps/backend/internal/service/interfaces.go
@apps/backend/cmd/trendy-api/serve.go (wiring pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncService with status aggregation</name>
  <files>apps/backend/internal/service/sync.go, apps/backend/internal/service/interfaces.go</files>
  <action>
**In interfaces.go**, add SyncService interface:
```go
// SyncService provides sync status information
type SyncService interface {
    GetSyncStatus(ctx context.Context, userID string) (*SyncStatus, error)
}
```

**Create sync.go** with SyncStatus model and service implementation:

```go
package service

import (
    "context"
    "sync"
    "time"

    "github.com/JonnyWalker81/trendy/backend/internal/repository"
)

// SyncStatus represents comprehensive sync state for a user
type SyncStatus struct {
    // Audit trail
    LastSync      *time.Time `json:"last_sync,omitempty"`       // When client last synced (from change_log)
    LastEvent     *time.Time `json:"last_event,omitempty"`      // Most recent event timestamp
    LastEventType *time.Time `json:"last_event_type,omitempty"` // Most recent event_type change

    // Counts for client verification
    Counts SyncCounts `json:"counts"`

    // HealthKit-specific section
    HealthKit HealthKitStatus `json:"healthkit"`

    // Change log cursor (for sync resumption)
    LatestCursor int64 `json:"latest_cursor"`

    // Recommendations
    Status          string   `json:"status"` // "all_synced" | "pending_changes" | "resync_recommended"
    Recommendations []string `json:"recommendations,omitempty"`
}

type SyncCounts struct {
    Events     int64 `json:"events"`
    EventTypes int64 `json:"event_types"`
}

type HealthKitStatus struct {
    LastSync *time.Time `json:"last_sync,omitempty"`
    Count    int64      `json:"count"`
}

type syncService struct {
    eventRepo     repository.EventRepository
    eventTypeRepo repository.EventTypeRepository
    changeLogRepo repository.ChangeLogRepository
}

func NewSyncService(
    eventRepo repository.EventRepository,
    eventTypeRepo repository.EventTypeRepository,
    changeLogRepo repository.ChangeLogRepository,
) SyncService {
    return &syncService{
        eventRepo:     eventRepo,
        eventTypeRepo: eventTypeRepo,
        changeLogRepo: changeLogRepo,
    }
}
```

**GetSyncStatus implementation:**
- Use goroutines with sync.WaitGroup for parallel queries (counts are independent)
- Query event count by user
- Query event_type count by user
- Query HealthKit event count (events where healthkit_sample_id is not null)
- Get latest change_log cursor
- Compute status recommendation based on data

Add necessary repository methods if missing:
- EventRepository.CountByUser(ctx, userID) (int64, error)
- EventRepository.CountHealthKitByUser(ctx, userID) (int64, error)
- EventTypeRepository.CountByUser(ctx, userID) (int64, error)

For timestamps (LastEvent, LastEventType), query most recent updated_at from each table.
  </action>
  <verify>
```bash
cd apps/backend && go build ./internal/service/...
```
No compile errors.
  </verify>
  <done>SyncService exists with GetSyncStatus method. SyncStatus struct includes counts, HealthKit section, cursor, and recommendations.</done>
</task>

<task type="auto">
  <name>Task 2: Add repository count methods</name>
  <files>apps/backend/internal/repository/event.go, apps/backend/internal/repository/event_type.go, apps/backend/internal/repository/interfaces.go</files>
  <action>
Add count methods needed by SyncService:

**In interfaces.go**, add to EventRepository:
```go
// CountByUser returns total events for a user
CountByUser(ctx context.Context, userID string) (int64, error)

// CountHealthKitByUser returns HealthKit events for a user
CountHealthKitByUser(ctx context.Context, userID string) (int64, error)

// GetLatestTimestamp returns the most recent event timestamp for a user
GetLatestTimestamp(ctx context.Context, userID string) (*time.Time, error)
```

Add to EventTypeRepository:
```go
// CountByUser returns total event types for a user
CountByUser(ctx context.Context, userID string) (int64, error)

// GetLatestTimestamp returns the most recent event_type updated_at for a user
GetLatestTimestamp(ctx context.Context, userID string) (*time.Time, error)
```

**In event.go**, implement count methods using PostgREST:
```go
func (r *eventRepository) CountByUser(ctx context.Context, userID string) (int64, error) {
    // PostgREST count: use select=count with Prefer: count=exact
    // Or query all IDs and count (simpler but less efficient for large datasets)
    // For now, use simple approach - can optimize later if needed
    query := map[string]interface{}{
        "user_id": fmt.Sprintf("eq.%s", userID),
        "select":  "id",
    }
    body, err := r.client.Query("events", query)
    if err != nil {
        return 0, err
    }
    var events []struct{ ID string }
    if err := json.Unmarshal(body, &events); err != nil {
        return 0, err
    }
    return int64(len(events)), nil
}

func (r *eventRepository) CountHealthKitByUser(ctx context.Context, userID string) (int64, error) {
    query := map[string]interface{}{
        "user_id":             fmt.Sprintf("eq.%s", userID),
        "healthkit_sample_id": "not.is.null",
        "select":              "id",
    }
    // ... similar to CountByUser
}

func (r *eventRepository) GetLatestTimestamp(ctx context.Context, userID string) (*time.Time, error) {
    query := map[string]interface{}{
        "user_id": fmt.Sprintf("eq.%s", userID),
        "select":  "updated_at",
        "order":   "updated_at.desc",
        "limit":   1,
    }
    // ... return most recent timestamp or nil if no events
}
```

Similar implementations for event_type.go.
  </action>
  <verify>
```bash
cd apps/backend && go build ./internal/repository/...
```
No compile errors.
  </verify>
  <done>Repository has CountByUser, CountHealthKitByUser, and GetLatestTimestamp methods for both events and event_types.</done>
</task>

<task type="auto">
  <name>Task 3: Create sync handler and wire up route</name>
  <files>apps/backend/internal/handlers/sync.go, apps/backend/cmd/trendy-api/serve.go</files>
  <action>
**Create handlers/sync.go:**
```go
package handlers

import (
    "net/http"

    "github.com/JonnyWalker81/trendy/backend/internal/apierror"
    "github.com/JonnyWalker81/trendy/backend/internal/service"
    "github.com/gin-gonic/gin"
)

type SyncHandler struct {
    syncService service.SyncService
}

func NewSyncHandler(syncService service.SyncService) *SyncHandler {
    return &SyncHandler{syncService: syncService}
}

// GetSyncStatus handles GET /api/v1/me/sync
func (h *SyncHandler) GetSyncStatus(c *gin.Context) {
    userID, exists := c.Get("user_id")
    if !exists {
        requestID := c.GetHeader("X-Request-ID")
        apierror.WriteProblem(c, apierror.NewUnauthorizedError(requestID))
        return
    }

    status, err := h.syncService.GetSyncStatus(c.Request.Context(), userID.(string))
    if err != nil {
        requestID := c.GetHeader("X-Request-ID")
        apierror.WriteProblem(c, apierror.NewInternalError(requestID))
        return
    }

    // Set cache header per CONTEXT.md (30 second cache)
    c.Header("Cache-Control", "private, max-age=30")
    c.JSON(http.StatusOK, status)
}
```

**In serve.go**, add wiring:
1. Create syncService with NewSyncService(eventRepo, eventTypeRepo, changeLogRepo)
2. Create syncHandler with NewSyncHandler(syncService)
3. Add route in protected group: `protected.GET("/me/sync", syncHandler.GetSyncStatus)`

Add after existing service initializations:
```go
syncService := service.NewSyncService(eventRepo, eventTypeRepo, changeLogRepo)
```

Add after existing handler initializations:
```go
syncHandler := handlers.NewSyncHandler(syncService)
```

Add route in protected block:
```go
// Sync status
protected.GET("/me/sync", syncHandler.GetSyncStatus)
```
  </action>
  <verify>
```bash
cd apps/backend && go build ./...

# Start server and test endpoint
cd apps/backend && go run ./cmd/trendy-api serve &
sleep 2
curl -s http://localhost:8080/api/v1/me/sync -H "Authorization: Bearer $TOKEN" | jq .
# Should return SyncStatus JSON with counts, healthkit section, cursor, status
```
  </verify>
  <done>GET /api/v1/me/sync endpoint exists and returns SyncStatus. Response includes 30-second cache header. Endpoint is protected by auth middleware.</done>
</task>

</tasks>

<verification>
```bash
# Build verification
cd apps/backend && go build ./...

# Start server (in background)
cd apps/backend && go run ./cmd/trendy-api serve &
API_PID=$!
sleep 3

# Test sync endpoint (requires valid auth token)
# Get a token first via login
TOKEN=$(curl -s -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"testpass"}' | jq -r '.access_token')

# Test sync status
curl -s http://localhost:8080/api/v1/me/sync \
  -H "Authorization: Bearer $TOKEN" | jq .

# Verify response structure
# Should have: counts, healthkit, latest_cursor, status, recommendations

# Check cache header
curl -sI http://localhost:8080/api/v1/me/sync \
  -H "Authorization: Bearer $TOKEN" | grep -i cache-control

# Cleanup
kill $API_PID
```
</verification>

<success_criteria>
- GET /api/v1/me/sync endpoint exists
- Response includes counts (events, event_types)
- Response includes healthkit section (last_sync, count)
- Response includes latest_cursor (change_log cursor)
- Response includes status field with recommendation
- Response has Cache-Control: private, max-age=30 header
- Endpoint requires authentication
- Errors use RFC 9457 ProblemDetails format
</success_criteria>

<output>
After completion, create `.planning/phases/06-server-api/06-03-SUMMARY.md`
</output>
