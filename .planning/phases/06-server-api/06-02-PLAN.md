---
phase: 06-server-api
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/backend/internal/service/uuid.go
  - apps/backend/internal/service/event.go
  - apps/backend/internal/repository/event.go
  - apps/backend/internal/handlers/event.go
autonomous: true

must_haves:
  truths:
    - "Server validates that event IDs are UUIDv7 format"
    - "Server rejects UUIDv7 timestamps more than 1 minute in future"
    - "Duplicate event IDs return 200 with existing record (idempotent)"
    - "Batch creates report per-item status with created/deduplicated/failed counts"
  artifacts:
    - path: "apps/backend/internal/service/uuid.go"
      provides: "UUIDv7 validation with time extraction"
      exports: ["ValidateUUIDv7", "ErrInvalidUUID", "ErrNotUUIDv7", "ErrFutureTimestamp"]
    - path: "apps/backend/internal/service/event.go"
      provides: "Event service with UUIDv7 validation"
      contains: "ValidateUUIDv7"
    - path: "apps/backend/internal/repository/event.go"
      provides: "Upsert method for idempotent creates"
      exports: ["Upsert", "UpsertBatch"]
    - path: "apps/backend/internal/handlers/event.go"
      provides: "Handlers returning RFC 9457 errors"
      contains: "apierror.WriteProblem"
  key_links:
    - from: "apps/backend/internal/service/event.go"
      to: "apps/backend/internal/service/uuid.go"
      via: "ValidateUUIDv7 call in CreateEvent"
      pattern: "ValidateUUIDv7\\("
    - from: "apps/backend/internal/handlers/event.go"
      to: "apps/backend/internal/apierror"
      via: "RFC 9457 error responses"
      pattern: "apierror\\.(WriteProblem|New)"
    - from: "apps/backend/internal/repository/event.go"
      to: "pkg/supabase.Upsert"
      via: "PostgREST upsert for deduplication"
      pattern: "client\\.Upsert"
---

<objective>
Implement UUIDv7 validation and idempotent event creation with upsert.

Purpose: Accept client-generated UUIDv7 IDs, validate format and embedded timestamp, and use upsert to make creates idempotent. Duplicate IDs return 200 with existing record per CONTEXT.md decisions.

Output: UUIDv7 validation service, updated event repository with upsert, handlers using RFC 9457 errors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-server-api/06-CONTEXT.md
@.planning/phases/06-server-api/06-RESEARCH.md

# Prior plan context
@.planning/phases/06-server-api/06-01-SUMMARY.md

# Existing code
@apps/backend/internal/service/event.go
@apps/backend/internal/repository/event.go
@apps/backend/internal/handlers/event.go
@apps/backend/pkg/supabase/client.go (has Upsert method)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UUIDv7 validation service</name>
  <files>apps/backend/internal/service/uuid.go, apps/backend/internal/service/uuid_test.go</files>
  <action>
Create uuid.go with UUIDv7 validation using existing `github.com/google/uuid` v1.6.0:

```go
package service

import (
    "errors"
    "fmt"
    "time"

    "github.com/google/uuid"
)

var (
    ErrInvalidUUID      = errors.New("invalid UUID format")
    ErrNotUUIDv7        = errors.New("UUID must be version 7")
    ErrFutureTimestamp  = errors.New("UUID timestamp is too far in the future")
)

// MaxFutureMinutes is the tolerance for UUIDv7 timestamp validation (1 minute per CONTEXT.md)
const MaxFutureMinutes = 1

// ValidateUUIDv7 validates that a string is a valid UUIDv7 with timestamp within bounds.
// Returns nil if valid, or ErrInvalidUUID, ErrNotUUIDv7, or ErrFutureTimestamp.
func ValidateUUIDv7(id string) error {
    parsed, err := uuid.Parse(id)
    if err != nil {
        return fmt.Errorf("%w: %v", ErrInvalidUUID, err)
    }

    if parsed.Version() != 7 {
        return fmt.Errorf("%w: got version %d", ErrNotUUIDv7, parsed.Version())
    }

    // Extract timestamp from UUIDv7
    // UUID.Time() returns 100-nanosecond intervals since Oct 15, 1582
    // For UUIDv7, this is derived from embedded Unix milliseconds
    sec, nsec := parsed.Time().UnixTime()
    timestamp := time.Unix(sec, nsec)

    // Reject if more than MaxFutureMinutes in the future
    maxAllowed := time.Now().Add(time.Duration(MaxFutureMinutes) * time.Minute)
    if timestamp.After(maxAllowed) {
        return fmt.Errorf("%w: %v is more than %d minute(s) ahead",
            ErrFutureTimestamp, timestamp.Format(time.RFC3339), MaxFutureMinutes)
    }

    return nil
}

// ExtractUUIDv7Timestamp extracts the embedded timestamp from a UUIDv7.
// Returns zero time if parsing fails.
func ExtractUUIDv7Timestamp(id string) time.Time {
    parsed, err := uuid.Parse(id)
    if err != nil {
        return time.Time{}
    }
    sec, nsec := parsed.Time().UnixTime()
    return time.Unix(sec, nsec)
}
```

Create uuid_test.go with tests:
- Valid UUIDv7 passes validation
- UUIDv4 fails with ErrNotUUIDv7
- Malformed UUID fails with ErrInvalidUUID
- UUIDv7 with future timestamp (>1 min) fails with ErrFutureTimestamp
- UUIDv7 with past timestamp passes
- UUIDv7 with timestamp just under 1 minute in future passes

Generate test UUIDs using `uuid.NewV7()` for valid cases, and `uuid.New()` for v4 cases.
  </action>
  <verify>
```bash
cd apps/backend && go test ./internal/service/uuid_test.go ./internal/service/uuid.go -v
```
All tests pass.
  </verify>
  <done>UUIDv7 validation service exists with version check and timestamp bounds check. Tests cover all error cases.</done>
</task>

<task type="auto">
  <name>Task 2: Update repository with upsert for events</name>
  <files>apps/backend/internal/repository/event.go, apps/backend/internal/repository/interfaces.go</files>
  <action>
Add upsert method to EventRepository for idempotent creates:

**In interfaces.go**, add to EventRepository interface:
```go
// Upsert creates or updates an event by ID. Returns (event, wasCreated, error).
// wasCreated is true if this was a new insert, false if existing was updated.
Upsert(ctx context.Context, event *models.Event) (*models.Event, bool, error)

// UpsertBatch creates or updates multiple events by ID.
// Returns (events, results) where results contains per-item status.
UpsertBatch(ctx context.Context, events []models.Event) ([]models.Event, []UpsertResult, error)
```

Add UpsertResult type:
```go
type UpsertResult struct {
    Index      int    // Position in original request
    ID         string // Event ID
    Action     string // "created" | "deduplicated" | "failed"
    Error      error  // Non-nil if Action is "failed"
}
```

**In event.go**, implement Upsert:
```go
func (r *eventRepository) Upsert(ctx context.Context, event *models.Event) (*models.Event, bool, error) {
    data := buildEventData(event)  // Extract existing data building to helper

    // Use PostgREST upsert on primary key "id"
    body, err := r.client.Upsert("events", data, "id")
    if err != nil {
        return nil, false, fmt.Errorf("failed to upsert event: %w", err)
    }

    var events []models.Event
    if err := json.Unmarshal(body, &events); err != nil {
        return nil, false, fmt.Errorf("failed to unmarshal response: %w", err)
    }

    if len(events) == 0 {
        return nil, false, fmt.Errorf("no event returned from upsert")
    }

    // Determine if created or updated by checking CreatedAt vs UpdatedAt
    // If they're within 1 second, it was likely just created
    wasCreated := events[0].UpdatedAt.Sub(events[0].CreatedAt) < time.Second

    return &events[0], wasCreated, nil
}
```

Extract common data building logic from Create() into a helper function `buildEventData(event *models.Event) map[string]interface{}` to avoid duplication.

UpsertBatch should process events in a single PostgREST call using the batch upsert capability. Track which events were created vs deduplicated by querying before upserting (similar to existing UpsertHealthKitEventsBatch pattern, but using event.ID as the key).
  </action>
  <verify>
```bash
cd apps/backend && go build ./internal/repository/...
```
No compile errors.
  </verify>
  <done>EventRepository has Upsert and UpsertBatch methods using PostgREST upsert on primary key. UpsertResult type exists for batch status tracking.</done>
</task>

<task type="auto">
  <name>Task 3: Update service and handlers for UUIDv7 + idempotency</name>
  <files>apps/backend/internal/service/event.go, apps/backend/internal/handlers/event.go</files>
  <action>
**In service/event.go:**

Update CreateEvent to:
1. If request has client-provided ID, validate it's UUIDv7 using ValidateUUIDv7()
2. Use repository.Upsert instead of Create for idempotent behavior
3. Return appropriate error types for validation failures

```go
func (s *eventService) CreateEvent(ctx context.Context, userID string, req *models.CreateEventRequest) (*models.Event, bool, error) {
    // Validate UUIDv7 if client-provided
    if req.ID != nil && *req.ID != "" {
        if err := ValidateUUIDv7(*req.ID); err != nil {
            return nil, false, err // Service returns validation error, handler translates to ProblemDetails
        }
    }

    // Build event and call Upsert
    event := &models.Event{...}
    if req.ID != nil {
        event.ID = *req.ID
    }

    result, wasCreated, err := s.eventRepo.Upsert(ctx, event)
    // ... rest of logic
    return result, wasCreated, nil
}
```

NOTE: The return signature changes to include `wasCreated bool`. Update the interface in interfaces.go accordingly.

**In handlers/event.go:**

Update CreateEvent handler to:
1. Use apierror package for error responses
2. Return 200 for deduplicated (wasCreated=false), 201 for new creates
3. Include ProblemDetails for validation errors

```go
func (h *EventHandler) CreateEvent(c *gin.Context) {
    // ... existing auth check ...

    event, wasCreated, err := h.eventService.CreateEvent(c.Request.Context(), userID.(string), &req)
    if err != nil {
        requestID := c.GetHeader("X-Request-ID")

        if errors.Is(err, service.ErrInvalidUUID) || errors.Is(err, service.ErrNotUUIDv7) {
            problem := apierror.NewBadRequestError(requestID, err.Error(), "Invalid event ID format")
            problem.Type = apierror.TypeInvalidUUID
            apierror.WriteProblem(c, problem)
            return
        }
        if errors.Is(err, service.ErrFutureTimestamp) {
            problem := apierror.NewBadRequestError(requestID, err.Error(), "Event ID contains future timestamp")
            problem.Type = apierror.TypeFutureTimestamp
            apierror.WriteProblem(c, problem)
            return
        }

        // Other errors
        apierror.WriteProblem(c, apierror.NewInternalError(requestID))
        return
    }

    if wasCreated {
        c.JSON(http.StatusCreated, event)
    } else {
        // Idempotent: return existing record with 200
        c.JSON(http.StatusOK, event)
    }
}
```

Similarly update CreateEventsBatch to use UpsertBatch and return BatchResponse with per-item status.
  </action>
  <verify>
```bash
cd apps/backend && go build ./...
cd apps/backend && go test ./internal/service/... -v
```
Build succeeds. Existing tests pass (update tests if needed for new return signature).
  </verify>
  <done>Service validates UUIDv7 on create. Handler returns 201 for new, 200 for deduplicated. Errors use RFC 9457 ProblemDetails format.</done>
</task>

</tasks>

<verification>
```bash
# Build verification
cd apps/backend && go build ./...

# Test verification
cd apps/backend && go test ./internal/service/... -v
cd apps/backend && go test ./internal/repository/... -v

# Manual API test (requires running server)
# Create event with UUIDv7 - should return 201
curl -X POST http://localhost:8080/api/v1/events \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"id":"019471a0-0000-7000-8000-000000000001","event_type_id":"...","timestamp":"2026-01-17T12:00:00Z"}'

# Retry same ID - should return 200 with same event
```
</verification>

<success_criteria>
- ValidateUUIDv7 function exists and validates version + timestamp bounds
- Repository Upsert method uses PostgREST upsert on primary key
- CreateEvent returns wasCreated boolean
- Handler returns 201 for new events, 200 for duplicates
- Invalid UUIDv7 returns RFC 9457 ProblemDetails with TypeInvalidUUID
- Future timestamp UUIDv7 returns RFC 9457 ProblemDetails with TypeFutureTimestamp
- Batch creates include created/deduplicated/failed counts
</success_criteria>

<output>
After completion, create `.planning/phases/06-server-api/06-02-SUMMARY.md`
</output>
