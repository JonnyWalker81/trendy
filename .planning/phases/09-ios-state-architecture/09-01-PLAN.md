---
phase: 09-ios-state-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/Services/APIClient.swift
  - apps/ios/trendy/Services/OnboardingStatusService.swift
  - apps/ios/trendy/Services/OnboardingCache.swift
  - apps/ios/trendy/Models/API/APIOnboardingStatus.swift
autonomous: true

must_haves:
  truths:
    - "Local cache stores per-user onboarding status"
    - "Cache read is synchronous (no async/await)"
    - "API client can fetch and update onboarding status from backend"
  artifacts:
    - path: "apps/ios/trendy/Models/API/APIOnboardingStatus.swift"
      provides: "Codable models matching backend OnboardingStatus schema"
      contains: "struct APIOnboardingStatus"
    - path: "apps/ios/trendy/Services/OnboardingCache.swift"
      provides: "Per-user keyed UserDefaults wrapper with synchronous read"
      contains: "static func read(userId:"
    - path: "apps/ios/trendy/Services/OnboardingStatusService.swift"
      provides: "Service combining API calls with cache management"
      contains: "class OnboardingStatusService"
    - path: "apps/ios/trendy/Services/APIClient.swift"
      provides: "Onboarding status endpoints"
      contains: "func getOnboardingStatus()"
  key_links:
    - from: "apps/ios/trendy/Services/OnboardingStatusService.swift"
      to: "apps/ios/trendy/Services/APIClient.swift"
      via: "apiClient.getOnboardingStatus()"
      pattern: "apiClient\\.getOnboardingStatus"
    - from: "apps/ios/trendy/Services/OnboardingStatusService.swift"
      to: "apps/ios/trendy/Services/OnboardingCache.swift"
      via: "OnboardingCache.write/read"
      pattern: "OnboardingCache\\.(write|read)"
---

<objective>
Create the data layer foundation for onboarding status: API models, local cache, and service.

Purpose: Enable synchronous cache reads for instant route determination and backend sync for cross-device status.
Output: APIOnboardingStatus model, OnboardingCache, OnboardingStatusService, and APIClient endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ios-state-architecture/09-CONTEXT.md
@.planning/phases/09-ios-state-architecture/09-RESEARCH.md
@.planning/phases/08-backend-onboarding-status/08-02-SUMMARY.md
@apps/ios/trendy/Services/APIClient.swift
@apps/ios/trendy/Services/SupabaseService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API models and endpoints</name>
  <files>
    apps/ios/trendy/Models/API/APIOnboardingStatus.swift
    apps/ios/trendy/Services/APIClient.swift
  </files>
  <action>
Create `apps/ios/trendy/Models/API/APIOnboardingStatus.swift` with:

```swift
/// API response model for onboarding status (matches backend OnboardingStatus)
struct APIOnboardingStatus: Codable {
    let userId: String
    let completed: Bool
    let welcomeCompletedAt: Date?
    let authCompletedAt: Date?
    let permissionsCompletedAt: Date?
    let notificationsStatus: String?
    let notificationsCompletedAt: Date?
    let healthkitStatus: String?
    let healthkitCompletedAt: Date?
    let locationStatus: String?
    let locationCompletedAt: Date?
    let createdAt: Date
    let updatedAt: Date

    enum CodingKeys: String, CodingKey {
        case userId = "user_id"
        case completed
        case welcomeCompletedAt = "welcome_completed_at"
        case authCompletedAt = "auth_completed_at"
        case permissionsCompletedAt = "permissions_completed_at"
        case notificationsStatus = "notifications_status"
        case notificationsCompletedAt = "notifications_completed_at"
        case healthkitStatus = "healthkit_status"
        case healthkitCompletedAt = "healthkit_completed_at"
        case locationStatus = "location_status"
        case locationCompletedAt = "location_completed_at"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
    }
}

/// Request model for updating onboarding status
struct UpdateOnboardingStatusRequest: Codable {
    var completed: Bool?
    var welcomeCompletedAt: Date?
    var authCompletedAt: Date?
    var permissionsCompletedAt: Date?
    var notificationsStatus: String?
    var notificationsCompletedAt: Date?
    var healthkitStatus: String?
    var healthkitCompletedAt: Date?
    var locationStatus: String?
    var locationCompletedAt: Date?

    enum CodingKeys: String, CodingKey {
        case completed
        case welcomeCompletedAt = "welcome_completed_at"
        case authCompletedAt = "auth_completed_at"
        case permissionsCompletedAt = "permissions_completed_at"
        case notificationsStatus = "notifications_status"
        case notificationsCompletedAt = "notifications_completed_at"
        case healthkitStatus = "healthkit_status"
        case healthkitCompletedAt = "healthkit_completed_at"
        case locationStatus = "location_status"
        case locationCompletedAt = "location_completed_at"
    }
}

/// Valid permission status values (matches backend CHECK constraint)
enum PermissionStatus: String, Codable {
    case granted
    case denied
    case skipped
    case notRequested = "not_requested"
}
```

Add to APIClient.swift (after Insights endpoints):

```swift
// MARK: - Onboarding Status Endpoints

/// Get current user's onboarding status (returns defaults for new users)
func getOnboardingStatus() async throws -> APIOnboardingStatus {
    return try await request("GET", endpoint: "/users/onboarding")
}

/// Update current user's onboarding status
func updateOnboardingStatus(_ request: UpdateOnboardingStatusRequest) async throws -> APIOnboardingStatus {
    return try await self.request("PATCH", endpoint: "/users/onboarding", body: request)
}

/// Reset onboarding status (soft reset - clears step timestamps, preserves permissions)
func resetOnboardingStatus() async throws -> APIOnboardingStatus {
    return try await request("DELETE", endpoint: "/users/onboarding")
}
```

Note: Use existing JSONEncoder/Decoder with `.iso8601` date strategy (already configured in APIClient).
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
APIOnboardingStatus model matches backend schema, APIClient has GET/PATCH/DELETE endpoints for /users/onboarding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OnboardingCache for per-user local storage</name>
  <files>
    apps/ios/trendy/Services/OnboardingCache.swift
  </files>
  <action>
Create `apps/ios/trendy/Services/OnboardingCache.swift`:

```swift
//
//  OnboardingCache.swift
//  trendy
//
//  Per-user local cache for onboarding status
//  Enables synchronous reads for instant route determination
//

import Foundation

/// Cached onboarding status for a specific user
struct CachedOnboardingStatus: Codable {
    let userId: String
    let completed: Bool
    let currentStep: String?  // For resuming incomplete onboarding
    let welcomeCompletedAt: Date?
    let authCompletedAt: Date?
    let permissionsCompletedAt: Date?
    let lastSyncedAt: Date?   // When we last synced with backend
    let lastUpdatedAt: Date   // When this cache entry was last modified

    /// Create from API response
    init(from api: APIOnboardingStatus) {
        self.userId = api.userId
        self.completed = api.completed
        self.currentStep = Self.determineCurrentStep(from: api)
        self.welcomeCompletedAt = api.welcomeCompletedAt
        self.authCompletedAt = api.authCompletedAt
        self.permissionsCompletedAt = api.permissionsCompletedAt
        self.lastSyncedAt = Date()
        self.lastUpdatedAt = Date()
    }

    /// Create for local-only update (before backend sync)
    init(userId: String, completed: Bool, currentStep: String?, welcomeCompletedAt: Date? = nil, authCompletedAt: Date? = nil, permissionsCompletedAt: Date? = nil, lastSyncedAt: Date? = nil) {
        self.userId = userId
        self.completed = completed
        self.currentStep = currentStep
        self.welcomeCompletedAt = welcomeCompletedAt
        self.authCompletedAt = authCompletedAt
        self.permissionsCompletedAt = permissionsCompletedAt
        self.lastSyncedAt = lastSyncedAt
        self.lastUpdatedAt = Date()
    }

    /// Determine current step from API response timestamps
    private static func determineCurrentStep(from api: APIOnboardingStatus) -> String? {
        if api.completed { return nil }
        if api.permissionsCompletedAt != nil { return "finish" }
        if api.authCompletedAt != nil { return "permissions" }
        if api.welcomeCompletedAt != nil { return "auth" }
        return "welcome"
    }
}

/// Per-user keyed UserDefaults cache for onboarding status
/// Enables synchronous reads for instant route determination without loading screens
enum OnboardingCache {

    private static let keyPrefix = "onboarding_status_"
    private static let anyCompletedKey = "onboarding_any_user_completed"

    // MARK: - Per-User Operations

    /// Generate cache key for a specific user
    private static func key(for userId: String) -> String {
        "\(keyPrefix)\(userId)"
    }

    /// Read cached status for a user (SYNCHRONOUS - no async)
    /// Returns nil if no cache exists for this user
    static func read(userId: String) -> CachedOnboardingStatus? {
        guard let data = UserDefaults.standard.data(forKey: key(for: userId)) else {
            return nil
        }
        return try? JSONDecoder().decode(CachedOnboardingStatus.self, from: data)
    }

    /// Write status to cache for a user
    static func write(_ status: CachedOnboardingStatus) {
        guard let data = try? JSONEncoder().encode(status) else {
            Log.auth.error("Failed to encode onboarding status for cache")
            return
        }
        UserDefaults.standard.set(data, forKey: key(for: status.userId))

        // Track if any user has completed onboarding (for returning user detection)
        if status.completed {
            UserDefaults.standard.set(true, forKey: anyCompletedKey)
        }

        Log.auth.debug("Cached onboarding status", context: .with { ctx in
            ctx.add("user_id", status.userId)
            ctx.add("completed", String(status.completed))
            ctx.add("current_step", status.currentStep ?? "nil")
        })
    }

    /// Clear cache for a specific user
    static func clear(userId: String) {
        UserDefaults.standard.removeObject(forKey: key(for: userId))
        Log.auth.debug("Cleared onboarding cache", context: .with { ctx in
            ctx.add("user_id", userId)
        })
    }

    // MARK: - Global Operations

    /// Check if ANY user has ever completed onboarding on this device
    /// Used to distinguish fresh installs from returning users who logged out
    static func hasAnyUserCompletedOnboarding() -> Bool {
        // Fast path: check the flag
        if UserDefaults.standard.bool(forKey: anyCompletedKey) {
            return true
        }

        // Fallback: scan all cache keys (handles migration from old flag)
        let allKeys = UserDefaults.standard.dictionaryRepresentation().keys
        for key in allKeys where key.hasPrefix(keyPrefix) {
            if let data = UserDefaults.standard.data(forKey: key),
               let status = try? JSONDecoder().decode(CachedOnboardingStatus.self, from: data),
               status.completed {
                // Update flag for future fast path
                UserDefaults.standard.set(true, forKey: anyCompletedKey)
                return true
            }
        }
        return false
    }

    /// Clear all onboarding caches (for debugging/testing)
    static func clearAll() {
        let allKeys = UserDefaults.standard.dictionaryRepresentation().keys
        for key in allKeys where key.hasPrefix(keyPrefix) {
            UserDefaults.standard.removeObject(forKey: key)
        }
        UserDefaults.standard.removeObject(forKey: anyCompletedKey)
        Log.auth.info("Cleared all onboarding caches")
    }
}
```

Key design decisions:
- `read(userId:)` is synchronous (no async) for instant route determination
- Per-user keying prevents status leakage between accounts
- `hasAnyUserCompletedOnboarding()` distinguishes fresh install from logged-out returning user
- Uses `Log.auth` for consistency with existing auth logging
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
OnboardingCache provides synchronous per-user reads and can detect if any user ever completed onboarding.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create OnboardingStatusService combining API + cache</name>
  <files>
    apps/ios/trendy/Services/OnboardingStatusService.swift
  </files>
  <action>
Create `apps/ios/trendy/Services/OnboardingStatusService.swift`:

```swift
//
//  OnboardingStatusService.swift
//  trendy
//
//  Service layer combining backend API with local cache
//  Handles sync, offline queuing, and cache updates
//

import Foundation

/// Service for managing onboarding status with backend sync and local cache
@Observable
@MainActor
class OnboardingStatusService {

    private let apiClient: APIClient
    private let supabaseService: SupabaseService

    /// Most recent status from cache or backend
    private(set) var currentStatus: CachedOnboardingStatus?

    /// Whether a sync operation is in progress
    private(set) var isSyncing = false

    /// Last sync error (if any)
    private(set) var lastSyncError: Error?

    init(apiClient: APIClient, supabaseService: SupabaseService) {
        self.apiClient = apiClient
        self.supabaseService = supabaseService
    }

    // MARK: - Synchronous Cache Access

    /// Read cached status for current user (SYNCHRONOUS)
    /// Returns nil if not authenticated or no cache
    func readCachedStatus() -> CachedOnboardingStatus? {
        guard let userId = try? supabaseService.getUserId() else {
            return nil
        }
        return OnboardingCache.read(userId: userId)
    }

    /// Check if current user has completed onboarding (from cache)
    func isOnboardingComplete() -> Bool {
        readCachedStatus()?.completed ?? false
    }

    /// Check if any user has ever completed onboarding on this device
    func hasAnyUserCompletedOnboarding() -> Bool {
        OnboardingCache.hasAnyUserCompletedOnboarding()
    }

    // MARK: - Backend Sync

    /// Sync onboarding status from backend and update cache
    /// Call this on login to ensure cache is current
    @discardableResult
    func syncFromBackend() async -> CachedOnboardingStatus? {
        guard let userId = try? supabaseService.getUserId() else {
            Log.auth.warning("Cannot sync onboarding status: not authenticated")
            return nil
        }

        isSyncing = true
        lastSyncError = nil
        defer { isSyncing = false }

        do {
            let apiStatus = try await apiClient.getOnboardingStatus()
            let cached = CachedOnboardingStatus(from: apiStatus)
            OnboardingCache.write(cached)
            currentStatus = cached

            Log.auth.info("Synced onboarding status from backend", context: .with { ctx in
                ctx.add("user_id", userId)
                ctx.add("completed", String(apiStatus.completed))
            })

            return cached
        } catch {
            lastSyncError = error
            Log.auth.error("Failed to sync onboarding status", error: error)

            // Return cached status as fallback
            return OnboardingCache.read(userId: userId)
        }
    }

    /// Sync with timeout - returns cached status if backend takes too long
    /// - Parameter timeout: Maximum time to wait for backend (default 3 seconds)
    func syncFromBackend(timeout: TimeInterval = 3.0) async -> CachedOnboardingStatus? {
        guard let userId = try? supabaseService.getUserId() else {
            return nil
        }

        // Start with cached status
        let cached = OnboardingCache.read(userId: userId)

        // Try to sync from backend with timeout
        do {
            let result = try await withThrowingTaskGroup(of: CachedOnboardingStatus?.self) { group in
                group.addTask {
                    return await self.syncFromBackend()
                }

                group.addTask {
                    try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
                    throw CancellationError()
                }

                // Return first successful result
                if let result = try await group.next() {
                    group.cancelAll()
                    return result
                }
                return cached
            }
            return result
        } catch {
            Log.auth.warning("Backend sync timed out, using cached status")
            return cached
        }
    }

    // MARK: - Status Updates

    /// Mark a step as completed and sync to backend
    /// Updates cache immediately, then pushes to backend (fire-and-forget)
    func markStepCompleted(_ step: OnboardingStep) async {
        guard let userId = try? supabaseService.getUserId() else {
            Log.auth.warning("Cannot mark step complete: not authenticated")
            return
        }

        // Build update request based on step
        var request = UpdateOnboardingStatusRequest()
        let now = Date()

        switch step {
        case .welcome:
            request.welcomeCompletedAt = now
        case .auth:
            request.authCompletedAt = now
        case .permissions, .finish:
            request.permissionsCompletedAt = now
        default:
            break
        }

        // Update cache immediately (before backend call)
        let currentCached = OnboardingCache.read(userId: userId)
        let updatedCached = CachedOnboardingStatus(
            userId: userId,
            completed: step == .finish,
            currentStep: step.next?.rawValue,
            welcomeCompletedAt: request.welcomeCompletedAt ?? currentCached?.welcomeCompletedAt,
            authCompletedAt: request.authCompletedAt ?? currentCached?.authCompletedAt,
            permissionsCompletedAt: request.permissionsCompletedAt ?? currentCached?.permissionsCompletedAt,
            lastSyncedAt: currentCached?.lastSyncedAt
        )
        OnboardingCache.write(updatedCached)
        currentStatus = updatedCached

        // Push to backend (fire-and-forget, will retry on next sync)
        Task.detached { [apiClient] in
            do {
                _ = try await apiClient.updateOnboardingStatus(request)
                Log.auth.debug("Pushed step completion to backend", context: .with { ctx in
                    ctx.add("step", step.rawValue)
                })
            } catch {
                Log.auth.warning("Failed to push step to backend (will retry)", error: error)
                // TODO: Queue for retry via SyncEngine if needed
            }
        }
    }

    /// Mark onboarding as complete
    func completeOnboarding() async {
        guard let userId = try? supabaseService.getUserId() else {
            Log.auth.warning("Cannot complete onboarding: not authenticated")
            return
        }

        // Update cache immediately
        let currentCached = OnboardingCache.read(userId: userId)
        let completedCached = CachedOnboardingStatus(
            userId: userId,
            completed: true,
            currentStep: nil,
            welcomeCompletedAt: currentCached?.welcomeCompletedAt,
            authCompletedAt: currentCached?.authCompletedAt,
            permissionsCompletedAt: Date(),
            lastSyncedAt: currentCached?.lastSyncedAt
        )
        OnboardingCache.write(completedCached)
        currentStatus = completedCached

        // Push to backend
        Task.detached { [apiClient] in
            do {
                let request = UpdateOnboardingStatusRequest(
                    completed: true,
                    permissionsCompletedAt: Date()
                )
                _ = try await apiClient.updateOnboardingStatus(request)
                Log.auth.info("Onboarding completion synced to backend")
            } catch {
                Log.auth.warning("Failed to sync completion to backend", error: error)
            }
        }
    }

    /// Reset onboarding (for testing/debug)
    func resetOnboarding() async {
        guard let userId = try? supabaseService.getUserId() else { return }

        // Clear local cache
        OnboardingCache.clear(userId: userId)
        currentStatus = nil

        // Reset on backend
        do {
            let resetStatus = try await apiClient.resetOnboardingStatus()
            let cached = CachedOnboardingStatus(from: resetStatus)
            OnboardingCache.write(cached)
            currentStatus = cached
            Log.auth.info("Onboarding reset complete")
        } catch {
            Log.auth.error("Failed to reset onboarding on backend", error: error)
        }
    }

    // MARK: - Logout Handling

    /// Handle user logout - preserves cache per CONTEXT.md
    /// "On logout: Keep onboarding cache - if user completed onboarding, don't show again on re-login"
    func handleLogout() {
        // Don't clear cache - user might re-login
        currentStatus = nil
        Log.auth.debug("Logout handled, cache preserved")
    }
}
```

Key design decisions per CONTEXT.md:
- `readCachedStatus()` is synchronous for instant route determination
- `markStepCompleted()` updates cache immediately, then pushes to backend (fire-and-forget)
- `handleLogout()` preserves cache so returning user doesn't re-onboard
- Backend sync has 3-second timeout fallback to cached status
- Uses `Log.auth` for consistency
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
OnboardingStatusService provides synchronous cache reads, backend sync with timeout, and step completion tracking.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds without errors
2. APIOnboardingStatus matches backend schema (see 08-02-SUMMARY)
3. OnboardingCache.read() has no async/await in signature
4. OnboardingStatusService uses both APIClient and OnboardingCache
</verification>

<success_criteria>
- [ ] APIOnboardingStatus model created with correct CodingKeys
- [ ] APIClient has getOnboardingStatus(), updateOnboardingStatus(), resetOnboardingStatus()
- [ ] OnboardingCache provides synchronous per-user read/write
- [ ] OnboardingCache.hasAnyUserCompletedOnboarding() works correctly
- [ ] OnboardingStatusService combines API calls with cache management
- [ ] All files build without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-ios-state-architecture/09-01-SUMMARY.md`
</output>
