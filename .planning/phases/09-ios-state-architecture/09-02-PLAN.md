---
phase: 09-ios-state-architecture
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - apps/ios/trendy/Services/AppRouter.swift
  - apps/ios/trendy/Views/RootView.swift
  - apps/ios/trendy/trendyApp.swift
autonomous: true

must_haves:
  truths:
    - "AppRouter determines route synchronously at launch (no async in hot path)"
    - "Returning authenticated user sees main app immediately (no loading flash)"
    - "Returning unauthenticated user sees login screen (not onboarding)"
    - "Fresh install shows onboarding"
  artifacts:
    - path: "apps/ios/trendy/Services/AppRouter.swift"
      provides: "Observable routing state machine with synchronous route determination"
      contains: "class AppRouter"
    - path: "apps/ios/trendy/Views/RootView.swift"
      provides: "Top-level view that switches on AppRoute enum"
      contains: "switch router.currentRoute"
    - path: "apps/ios/trendy/trendyApp.swift"
      provides: "AppRouter initialization and environment injection"
      contains: "environment(appRouter)"
  key_links:
    - from: "apps/ios/trendy/trendyApp.swift"
      to: "apps/ios/trendy/Services/AppRouter.swift"
      via: "determineInitialRoute() call in init"
      pattern: "appRouter\\.determineInitialRoute"
    - from: "apps/ios/trendy/Views/RootView.swift"
      to: "apps/ios/trendy/Services/AppRouter.swift"
      via: "Environment injection"
      pattern: "@Environment\\(AppRouter\\.self\\)"
---

<objective>
Create the AppRouter Observable and RootView that enable instant route determination.

Purpose: Eliminate loading flash by reading cached state synchronously before any UI renders.
Output: AppRouter with determineInitialRoute(), RootView with route-based switching, trendyApp wiring.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ios-state-architecture/09-CONTEXT.md
@.planning/phases/09-ios-state-architecture/09-RESEARCH.md
@.planning/phases/09-ios-state-architecture/09-01-SUMMARY.md
@apps/ios/trendy/trendyApp.swift
@apps/ios/trendy/Services/SupabaseService.swift
@apps/ios/trendy/Views/LoadingView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppRouter Observable with cache-first route determination</name>
  <files>
    apps/ios/trendy/Services/AppRouter.swift
  </files>
  <action>
Create `apps/ios/trendy/Services/AppRouter.swift`:

```swift
//
//  AppRouter.swift
//  trendy
//
//  Observable routing state machine for app-level navigation
//  Determines initial route synchronously to prevent loading flash
//
//  DESIGN: Cache-first strategy per CONTEXT.md
//  - Returning users with cache: instant route (no loading)
//  - Session restore happens async in background
//  - This avoids race condition with SupabaseService.restoreSession()
//

import Foundation
import SwiftUI

/// App-level route states
enum AppRoute: Equatable {
    case loading              // Brief loading while checking backend (cache miss only)
    case onboarding(step: OnboardingStep)  // New user onboarding flow
    case login                // Returning user, not authenticated
    case authenticated        // Main app
}

/// Observable router that manages app-level navigation state
/// Key feature: determineInitialRoute() is SYNCHRONOUS for instant routing
@Observable
@MainActor
class AppRouter {

    // MARK: - Published State

    /// Current route state
    private(set) var currentRoute: AppRoute = .loading

    // MARK: - Dependencies

    private let supabaseService: SupabaseService
    private let onboardingService: OnboardingStatusService

    // MARK: - Initialization

    init(supabaseService: SupabaseService, onboardingService: OnboardingStatusService) {
        self.supabaseService = supabaseService
        self.onboardingService = onboardingService
    }

    // MARK: - Route Determination

    /// Determine initial route SYNCHRONOUSLY from cached state
    /// Call this ONCE at app launch, before body is rendered
    ///
    /// IMPORTANT: Uses CACHE-FIRST strategy to avoid race condition.
    /// SupabaseService.restoreSession() is async (runs in Task in init),
    /// so currentSession may not be populated at this point.
    ///
    /// Strategy:
    /// 1. Check if ANY user has completed onboarding on this device
    /// 2. If yes AND cache exists for a user -> use cache to route
    /// 3. If cache exists with userId -> trust cache, session restore will happen in background
    /// 4. If no cache -> fresh install or logged-out user
    ///
    /// Key design: NO async in hot path - cache hit = instant route
    func determineInitialRoute() {
        // CACHE-FIRST: Don't rely on supabaseService.currentSession being populated
        // It may not be ready yet since restoreSession() is async

        // Check if we have ANY cached onboarding status (indicates returning user)
        let hasAnyCompletedUser = OnboardingCache.hasAnyUserCompletedOnboarding()

        Log.auth.debug("determineInitialRoute (cache-first)", context: .with { ctx in
            ctx.add("has_any_completed", String(hasAnyCompletedUser))
        })

        // Try to find a cached user with completed onboarding
        // This handles the common case: user completed onboarding, closed app, reopened
        if let cachedStatus = findMostRecentCachedStatus() {
            if cachedStatus.completed {
                // Returning user with completed onboarding
                // Session will restore in background, we'll handle auth failure later
                Log.auth.info("Route: authenticated (cache-first, completed)")
                currentRoute = .authenticated

                // Kick off background session verification
                Task { await verifySessionInBackground() }
                return
            } else if let stepRaw = cachedStatus.currentStep,
                      let step = OnboardingStep(rawValue: stepRaw) {
                // Incomplete onboarding - resume from cached step
                Log.auth.info("Route: onboarding (cache-first, resume)", context: .with { ctx in
                    ctx.add("step", stepRaw)
                })
                currentRoute = .onboarding(step: step)
                return
            }
        }

        // No usable cache - check if returning user (logged out) or fresh install
        if hasAnyCompletedUser {
            // Someone completed onboarding on this device before, but no cache for current user
            // This is a logged-out returning user -> show login
            Log.auth.info("Route: login (returning user, no current cache)")
            currentRoute = .login
        } else {
            // Fresh install - no one has ever completed onboarding on this device
            Log.auth.info("Route: onboarding (fresh install)")
            currentRoute = .onboarding(step: .welcome)
        }
    }

    /// Find most recent cached onboarding status
    /// Returns nil if no cache exists
    private func findMostRecentCachedStatus() -> CachedOnboardingStatus? {
        // First, try to get userId from cached session (sync)
        if let userId = try? supabaseService.getUserId() {
            return OnboardingCache.read(userId: userId)
        }

        // If no session, we can't determine user-specific cache
        // But we can check the "any completed" flag for routing decision
        return nil
    }

    /// Verify session is valid in background after cache-based routing
    /// If session is invalid, transition to login
    private func verifySessionInBackground() async {
        // Give SupabaseService time to restore session
        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5s

        // Now check if session was restored
        if supabaseService.currentSession == nil {
            Log.auth.warning("Session not restored, transitioning to login")
            transitionToLogin()
        } else {
            // Session valid - sync from backend in background
            _ = await onboardingService.syncFromBackend(timeout: 3.0)
            Log.auth.debug("Background session verification complete")
        }
    }

    // MARK: - Route Transitions

    /// Transition to main app (after onboarding completes)
    func transitionToAuthenticated() {
        Log.auth.info("Route transition: authenticated")
        currentRoute = .authenticated
    }

    /// Transition to login (after logout)
    func transitionToLogin() {
        Log.auth.info("Route transition: login")
        currentRoute = .login
    }

    /// Transition to onboarding (for new user or reset)
    func transitionToOnboarding(step: OnboardingStep = .welcome) {
        Log.auth.info("Route transition: onboarding", context: .with { ctx in
            ctx.add("step", step.rawValue)
        })
        currentRoute = .onboarding(step: step)
    }

    /// Update onboarding step (during flow)
    func updateOnboardingStep(_ step: OnboardingStep) {
        guard case .onboarding = currentRoute else { return }
        currentRoute = .onboarding(step: step)
    }

    // MARK: - Auth Event Handlers

    /// Handle successful login - sync and route
    /// Called from LoginView after AuthViewModel.signIn() succeeds
    func handleLogin() async {
        guard let userId = supabaseService.currentSession?.user.id.uuidString else {
            Log.auth.warning("handleLogin called but no session")
            return
        }

        Log.auth.info("handleLogin: syncing status for user", context: .with { ctx in
            ctx.add("user_id", userId)
        })

        // Sync from backend to get latest status
        let status = await onboardingService.syncFromBackend(timeout: 3.0)

        if let status = status, status.completed {
            // Returning user with completed onboarding
            transitionToAuthenticated()
        } else {
            // New user or incomplete onboarding - continue flow
            // Determine which step based on cached/synced state
            if let status = status, let stepRaw = status.currentStep,
               let step = OnboardingStep(rawValue: stepRaw) {
                transitionToOnboarding(step: step)
            } else {
                // Default: after auth, go to createEventType (first post-auth step)
                transitionToOnboarding(step: .createEventType)
            }
        }
    }

    /// Handle logout - preserve cache, transition to login
    func handleLogout() {
        onboardingService.handleLogout()
        transitionToLogin()
    }

    /// Handle onboarding completion
    func handleOnboardingComplete() async {
        await onboardingService.completeOnboarding()
        transitionToAuthenticated()
    }
}
```

Key design decisions per CONTEXT.md:
- **CACHE-FIRST strategy**: Avoids race condition with SupabaseService.restoreSession()
- `determineInitialRoute()` is FULLY SYNCHRONOUS - no async/await
- Does NOT rely on `supabaseService.currentSession` which may not be populated at init time
- Cache hit = instant route, no loading state shown
- Background session verification kicks off after routing
- If session restore fails, gracefully transitions to login
- Distinguishes fresh install from logged-out returning user via `hasAnyUserCompletedOnboarding()`
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
AppRouter provides synchronous cache-first route determination that avoids race condition with async session restore.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RootView that switches on route state</name>
  <files>
    apps/ios/trendy/Views/RootView.swift
  </files>
  <action>
Create `apps/ios/trendy/Views/RootView.swift`:

```swift
//
//  RootView.swift
//  trendy
//
//  Top-level view that switches based on AppRouter state
//  Replaces ContentView as the main routing container
//

import SwiftUI

/// Root view that displays content based on current route
struct RootView: View {
    @Environment(AppRouter.self) private var router
    @Environment(AuthViewModel.self) private var authViewModel

    var body: some View {
        Group {
            switch router.currentRoute {
            case .loading:
                // Brief loading state - only shown for cache miss
                // Matches launch screen aesthetic per CONTEXT.md
                LaunchLoadingView()

            case .onboarding(let step):
                // Onboarding flow with starting step
                OnboardingContainerView()

            case .login:
                // Returning unauthenticated user - show login directly
                // Skip welcome/intro since they've seen it before
                LoginView()

            case .authenticated:
                // Main app
                MainTabView()
            }
        }
        .animation(.easeInOut(duration: 0.3), value: router.currentRoute)
    }
}

/// Loading view matching launch screen aesthetic
/// Per CONTEXT.md: "Loading screen matches Launch Screen aesthetic (seamless transition)"
private struct LaunchLoadingView: View {
    var body: some View {
        ZStack {
            // Match launch screen background
            Color.dsBackground
                .ignoresSafeArea()

            VStack(spacing: 20) {
                // App icon or logo placeholder
                // Could add actual app icon here for seamless transition
                Image(systemName: "chart.line.uptrend.xyaxis")
                    .font(.system(size: 60))
                    .foregroundStyle(Color.dsPrimary)

                // Subtle loading indicator
                ProgressView()
                    .progressViewStyle(.circular)
                    .tint(Color.dsMutedForeground)
            }
        }
    }
}

#Preview("Loading") {
    let previewConfig = SupabaseConfiguration(url: "http://127.0.0.1:54321", anonKey: "preview")
    let previewSupabase = SupabaseService(configuration: previewConfig)
    let previewAPIConfig = APIConfiguration(baseURL: "http://127.0.0.1:8080/api/v1")
    let previewAPIClient = APIClient(configuration: previewAPIConfig, supabaseService: previewSupabase)
    let previewOnboardingService = OnboardingStatusService(apiClient: previewAPIClient, supabaseService: previewSupabase)
    let previewRouter = AppRouter(supabaseService: previewSupabase, onboardingService: previewOnboardingService)

    return LaunchLoadingView()
        .environment(previewRouter)
        .environment(AuthViewModel(supabaseService: previewSupabase))
}

#Preview("Authenticated") {
    let previewConfig = SupabaseConfiguration(url: "http://127.0.0.1:54321", anonKey: "preview")
    let previewSupabase = SupabaseService(configuration: previewConfig)
    let previewAPIConfig = APIConfiguration(baseURL: "http://127.0.0.1:8080/api/v1")
    let previewAPIClient = APIClient(configuration: previewAPIConfig, supabaseService: previewSupabase)
    let previewOnboardingService = OnboardingStatusService(apiClient: previewAPIClient, supabaseService: previewSupabase)
    let previewRouter = AppRouter(supabaseService: previewSupabase, onboardingService: previewOnboardingService)

    return MainTabView()
        .modelContainer(for: [Event.self, EventType.self], inMemory: true)
        .environment(previewRouter)
        .environment(AuthViewModel(supabaseService: previewSupabase))
}
```

Note: RootView reads from AppRouter via environment. The actual route determination happens in trendyApp.init() before body is rendered.
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
RootView switches on router.currentRoute with animation between states.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire AppRouter in trendyApp.swift</name>
  <files>
    apps/ios/trendy/trendyApp.swift
  </files>
  <action>
Modify `apps/ios/trendy/trendyApp.swift`:

1. Add AppRouter and OnboardingStatusService as stored properties:
```swift
// Add after foundationModelService declaration
/// App router for navigation state
private let appRouter: AppRouter

/// Onboarding status service
private let onboardingStatusService: OnboardingStatusService
```

2. In `init()`, create OnboardingStatusService and AppRouter after apiClient creation:
```swift
// After: self.apiClient = APIClient(...)

// Initialize onboarding status service
self.onboardingStatusService = OnboardingStatusService(
    apiClient: apiClient,
    supabaseService: supabaseService
)

// Initialize app router
self.appRouter = AppRouter(
    supabaseService: supabaseService,
    onboardingService: onboardingStatusService
)

// Determine initial route SYNCHRONOUSLY before body renders
// This is the key to preventing loading flash
// Uses CACHE-FIRST strategy - does not wait for session restore
appRouter.determineInitialRoute()
```

3. Replace `ContentView()` with `RootView()` in body and add environment:
```swift
var body: some Scene {
    WindowGroup {
        RootView()  // Changed from ContentView()
            .environment(appRouter)  // Add this
            .environment(onboardingStatusService)  // Add this
            .environment(authViewModel)
            .environment(themeManager)
            .environment(insightsViewModel)
            .environment(syncStatusViewModel)
            .environment(syncHistoryStore)
            .environment(\.supabaseService, supabaseService)
            .environment(\.apiClient, apiClient)
            .environment(\.foundationModelService, foundationModelService)
            .preferredColorScheme(isUITestingDarkMode ? .dark : themeManager.currentTheme.colorScheme)
    }
    .modelContainer(sharedModelContainer)
}
```

4. Also handle screenshot mode - update the DEBUG block to use RootView pattern:
- For screenshot mode, you may need to set appRouter to .authenticated directly

IMPORTANT: The `appRouter.determineInitialRoute()` call MUST happen in init(), NOT in a Task or onAppear. This ensures synchronous route determination before SwiftUI renders body.

Note on session restore race condition:
- SupabaseService.init() calls `Task { await restoreSession() }` which is async
- Our cache-first strategy in AppRouter does NOT rely on currentSession being populated
- It reads from OnboardingCache directly, which is synchronous
- Background session verification happens AFTER initial route is determined
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
trendyApp creates AppRouter in init() and calls determineInitialRoute() synchronously before body renders using cache-first strategy.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds without errors
2. AppRouter.determineInitialRoute() has no `async` keyword
3. AppRouter uses cache-first strategy (does NOT rely on supabaseService.currentSession at init)
4. trendyApp calls appRouter.determineInitialRoute() in init() (not in Task)
5. RootView switches on router.currentRoute
6. Environment injection chain: trendyApp -> RootView -> AppRouter
</verification>

<success_criteria>
- [ ] AppRouter created with AppRoute enum (loading, onboarding, login, authenticated)
- [ ] determineInitialRoute() is synchronous (no async/await in signature)
- [ ] determineInitialRoute() uses cache-first strategy (no race condition with session restore)
- [ ] RootView displays different views based on route state
- [ ] trendyApp creates and wires AppRouter in init()
- [ ] determineInitialRoute() called synchronously before body renders
- [ ] All files build without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-ios-state-architecture/09-02-SUMMARY.md`
</output>
