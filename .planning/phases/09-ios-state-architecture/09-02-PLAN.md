---
phase: 09-ios-state-architecture
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - apps/ios/trendy/Services/AppRouter.swift
  - apps/ios/trendy/Views/RootView.swift
  - apps/ios/trendy/trendyApp.swift
autonomous: true

must_haves:
  truths:
    - "AppRouter determines route synchronously at launch (no async in hot path)"
    - "Returning authenticated user sees main app immediately (no loading flash)"
    - "Returning unauthenticated user sees login screen (not onboarding)"
    - "Fresh install shows onboarding"
  artifacts:
    - path: "apps/ios/trendy/Services/AppRouter.swift"
      provides: "Observable routing state machine with synchronous route determination"
      contains: "class AppRouter"
    - path: "apps/ios/trendy/Views/RootView.swift"
      provides: "Top-level view that switches on AppRoute enum"
      contains: "switch router.currentRoute"
    - path: "apps/ios/trendy/trendyApp.swift"
      provides: "AppRouter initialization and environment injection"
      contains: "environment(appRouter)"
  key_links:
    - from: "apps/ios/trendy/trendyApp.swift"
      to: "apps/ios/trendy/Services/AppRouter.swift"
      via: "determineInitialRoute() call in init"
      pattern: "appRouter\\.determineInitialRoute"
    - from: "apps/ios/trendy/Views/RootView.swift"
      to: "apps/ios/trendy/Services/AppRouter.swift"
      via: "Environment injection"
      pattern: "@Environment\\(AppRouter\\.self\\)"
---

<objective>
Create the AppRouter Observable and RootView that enable instant route determination.

Purpose: Eliminate loading flash by reading cached state synchronously before any UI renders.
Output: AppRouter with determineInitialRoute(), RootView with route-based switching, trendyApp wiring.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ios-state-architecture/09-CONTEXT.md
@.planning/phases/09-ios-state-architecture/09-RESEARCH.md
@.planning/phases/09-ios-state-architecture/09-01-SUMMARY.md
@apps/ios/trendy/trendyApp.swift
@apps/ios/trendy/Services/SupabaseService.swift
@apps/ios/trendy/Views/LoadingView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppRouter Observable with route determination</name>
  <files>
    apps/ios/trendy/Services/AppRouter.swift
  </files>
  <action>
Create `apps/ios/trendy/Services/AppRouter.swift`:

```swift
//
//  AppRouter.swift
//  trendy
//
//  Observable routing state machine for app-level navigation
//  Determines initial route synchronously to prevent loading flash
//

import Foundation
import SwiftUI

/// App-level route states
enum AppRoute: Equatable {
    case loading              // Brief loading while checking backend (cache miss only)
    case onboarding(step: OnboardingStep)  // New user onboarding flow
    case login                // Returning user, not authenticated
    case authenticated        // Main app
}

/// Observable router that manages app-level navigation state
/// Key feature: determineInitialRoute() is SYNCHRONOUS for instant routing
@Observable
@MainActor
class AppRouter {

    // MARK: - Published State

    /// Current route state
    private(set) var currentRoute: AppRoute = .loading

    // MARK: - Dependencies

    private let supabaseService: SupabaseService
    private let onboardingService: OnboardingStatusService

    // MARK: - Initialization

    init(supabaseService: SupabaseService, onboardingService: OnboardingStatusService) {
        self.supabaseService = supabaseService
        self.onboardingService = onboardingService
    }

    // MARK: - Route Determination

    /// Determine initial route SYNCHRONOUSLY from cached state
    /// Call this ONCE at app launch, before body is rendered
    /// Key design: NO async in hot path - cache hit = instant route
    func determineInitialRoute() {
        // Check auth state SYNCHRONOUSLY using cached session
        // Note: supabaseService.currentSession is populated from Keychain on init
        let hasSession = supabaseService.currentSession != nil
        let userId = supabaseService.currentSession?.user.id.uuidString

        Log.auth.debug("determineInitialRoute", context: .with { ctx in
            ctx.add("has_session", String(hasSession))
            ctx.add("user_id", userId ?? "nil")
        })

        if hasSession, let userId = userId {
            // Authenticated user - check per-user cache
            if let cached = OnboardingCache.read(userId: userId) {
                if cached.completed {
                    // Cache hit, completed - instant main app
                    Log.auth.info("Route: authenticated (cache hit, completed)")
                    currentRoute = .authenticated
                } else if let stepRaw = cached.currentStep,
                          let step = OnboardingStep(rawValue: stepRaw) {
                    // Cache hit, incomplete - resume onboarding
                    Log.auth.info("Route: onboarding (cache hit, resume)", context: .with { ctx in
                        ctx.add("step", stepRaw)
                    })
                    currentRoute = .onboarding(step: step)
                } else {
                    // Cache exists but no step - check permissions step
                    Log.auth.info("Route: onboarding (cache hit, no step)")
                    currentRoute = .onboarding(step: .permissions)
                }
            } else {
                // Cache miss - need to check backend
                // Show loading briefly while we sync
                Log.auth.info("Route: loading (cache miss, will sync)")
                currentRoute = .loading
                Task { await syncAndRoute(userId: userId) }
            }
        } else {
            // No session - check if returning user or fresh install
            if OnboardingCache.hasAnyUserCompletedOnboarding() {
                // Returning user who logged out - show login, not onboarding
                Log.auth.info("Route: login (returning user)")
                currentRoute = .login
            } else {
                // Fresh install - show onboarding
                Log.auth.info("Route: onboarding (fresh install)")
                currentRoute = .onboarding(step: .welcome)
            }
        }
    }

    /// Sync from backend and determine route (for cache miss scenario)
    private func syncAndRoute(userId: String) async {
        // Sync with 3-second timeout
        let status = await onboardingService.syncFromBackend(timeout: 3.0)

        if let status = status, status.completed {
            currentRoute = .authenticated
            Log.auth.info("Route after sync: authenticated")
        } else if let status = status, let stepRaw = status.currentStep,
                  let step = OnboardingStep(rawValue: stepRaw) {
            currentRoute = .onboarding(step: step)
            Log.auth.info("Route after sync: onboarding", context: .with { ctx in
                ctx.add("step", stepRaw)
            })
        } else {
            // Default to permissions step (after auth)
            currentRoute = .onboarding(step: .permissions)
            Log.auth.info("Route after sync: onboarding (default to permissions)")
        }
    }

    // MARK: - Route Transitions

    /// Transition to main app (after onboarding completes)
    func transitionToAuthenticated() {
        Log.auth.info("Route transition: authenticated")
        currentRoute = .authenticated
    }

    /// Transition to login (after logout)
    func transitionToLogin() {
        Log.auth.info("Route transition: login")
        currentRoute = .login
    }

    /// Transition to onboarding (for new user or reset)
    func transitionToOnboarding(step: OnboardingStep = .welcome) {
        Log.auth.info("Route transition: onboarding", context: .with { ctx in
            ctx.add("step", step.rawValue)
        })
        currentRoute = .onboarding(step: step)
    }

    /// Update onboarding step (during flow)
    func updateOnboardingStep(_ step: OnboardingStep) {
        guard case .onboarding = currentRoute else { return }
        currentRoute = .onboarding(step: step)
    }

    // MARK: - Auth Event Handlers

    /// Handle successful login - sync and route
    func handleLogin() async {
        guard let userId = supabaseService.currentSession?.user.id.uuidString else {
            Log.auth.warning("handleLogin called but no session")
            return
        }

        // Sync from backend to get latest status
        let status = await onboardingService.syncFromBackend(timeout: 3.0)

        if let status = status, status.completed {
            // Returning user with completed onboarding
            transitionToAuthenticated()
        } else {
            // New user or incomplete onboarding - continue flow
            // Determine which step based on cached/synced state
            if let status = status, let stepRaw = status.currentStep,
               let step = OnboardingStep(rawValue: stepRaw) {
                transitionToOnboarding(step: step)
            } else {
                // Default: after auth, go to permissions
                transitionToOnboarding(step: .permissions)
            }
        }
    }

    /// Handle logout - preserve cache, transition to login
    func handleLogout() {
        onboardingService.handleLogout()
        transitionToLogin()
    }

    /// Handle onboarding completion
    func handleOnboardingComplete() async {
        await onboardingService.completeOnboarding()
        transitionToAuthenticated()
    }
}
```

Key design decisions per CONTEXT.md and RESEARCH.md:
- `determineInitialRoute()` is FULLY SYNCHRONOUS - no async/await
- Uses `currentSession` (populated from Keychain on init) not async `auth.session`
- Cache hit = instant route, no loading state shown
- Only shows `.loading` for cache miss (authenticated user, no local cache)
- Distinguishes fresh install from logged-out returning user via `hasAnyUserCompletedOnboarding()`
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
AppRouter provides synchronous route determination with AppRoute enum states.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RootView that switches on route state</name>
  <files>
    apps/ios/trendy/Views/RootView.swift
  </files>
  <action>
Create `apps/ios/trendy/Views/RootView.swift`:

```swift
//
//  RootView.swift
//  trendy
//
//  Top-level view that switches based on AppRouter state
//  Replaces ContentView as the main routing container
//

import SwiftUI

/// Root view that displays content based on current route
struct RootView: View {
    @Environment(AppRouter.self) private var router
    @Environment(AuthViewModel.self) private var authViewModel

    var body: some View {
        Group {
            switch router.currentRoute {
            case .loading:
                // Brief loading state - only shown for cache miss
                // Matches launch screen aesthetic per CONTEXT.md
                LaunchLoadingView()

            case .onboarding(let step):
                // Onboarding flow with starting step
                OnboardingContainerView()

            case .login:
                // Returning unauthenticated user - show login directly
                // Skip welcome/intro since they've seen it before
                LoginView()

            case .authenticated:
                // Main app
                MainTabView()
            }
        }
        .animation(.easeInOut(duration: 0.3), value: router.currentRoute)
    }
}

/// Loading view matching launch screen aesthetic
/// Per CONTEXT.md: "Loading screen matches Launch Screen aesthetic (seamless transition)"
private struct LaunchLoadingView: View {
    var body: some View {
        ZStack {
            // Match launch screen background
            Color.dsBackground
                .ignoresSafeArea()

            VStack(spacing: 20) {
                // App icon or logo placeholder
                // Could add actual app icon here for seamless transition
                Image(systemName: "chart.line.uptrend.xyaxis")
                    .font(.system(size: 60))
                    .foregroundStyle(Color.dsPrimary)

                // Subtle loading indicator
                ProgressView()
                    .progressViewStyle(.circular)
                    .tint(Color.dsMutedForeground)
            }
        }
    }
}

#Preview("Loading") {
    let previewConfig = SupabaseConfiguration(url: "http://127.0.0.1:54321", anonKey: "preview")
    let previewSupabase = SupabaseService(configuration: previewConfig)
    let previewAPIConfig = APIConfiguration(baseURL: "http://127.0.0.1:8080/api/v1")
    let previewAPIClient = APIClient(configuration: previewAPIConfig, supabaseService: previewSupabase)
    let previewOnboardingService = OnboardingStatusService(apiClient: previewAPIClient, supabaseService: previewSupabase)
    let previewRouter = AppRouter(supabaseService: previewSupabase, onboardingService: previewOnboardingService)

    return LaunchLoadingView()
        .environment(previewRouter)
        .environment(AuthViewModel(supabaseService: previewSupabase))
}

#Preview("Authenticated") {
    let previewConfig = SupabaseConfiguration(url: "http://127.0.0.1:54321", anonKey: "preview")
    let previewSupabase = SupabaseService(configuration: previewConfig)
    let previewAPIConfig = APIConfiguration(baseURL: "http://127.0.0.1:8080/api/v1")
    let previewAPIClient = APIClient(configuration: previewAPIConfig, supabaseService: previewSupabase)
    let previewOnboardingService = OnboardingStatusService(apiClient: previewAPIClient, supabaseService: previewSupabase)
    let previewRouter = AppRouter(supabaseService: previewSupabase, onboardingService: previewOnboardingService)

    return MainTabView()
        .modelContainer(for: [Event.self, EventType.self], inMemory: true)
        .environment(previewRouter)
        .environment(AuthViewModel(supabaseService: previewSupabase))
}
```

Note: RootView reads from AppRouter via environment. The actual route determination happens in trendyApp.init() before body is rendered.
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
RootView switches on router.currentRoute with animation between states.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire AppRouter in trendyApp.swift</name>
  <files>
    apps/ios/trendy/trendyApp.swift
  </files>
  <action>
Modify `apps/ios/trendy/trendyApp.swift`:

1. Add AppRouter and OnboardingStatusService as stored properties:
```swift
// Add after foundationModelService declaration
/// App router for navigation state
private let appRouter: AppRouter

/// Onboarding status service
private let onboardingStatusService: OnboardingStatusService
```

2. In `init()`, create OnboardingStatusService and AppRouter after apiClient creation:
```swift
// After: self.apiClient = APIClient(...)

// Initialize onboarding status service
self.onboardingStatusService = OnboardingStatusService(
    apiClient: apiClient,
    supabaseService: supabaseService
)

// Initialize app router
self.appRouter = AppRouter(
    supabaseService: supabaseService,
    onboardingService: onboardingStatusService
)

// Determine initial route SYNCHRONOUSLY before body renders
// This is the key to preventing loading flash
appRouter.determineInitialRoute()
```

3. Replace `ContentView()` with `RootView()` in body and add environment:
```swift
var body: some Scene {
    WindowGroup {
        RootView()  // Changed from ContentView()
            .environment(appRouter)  // Add this
            .environment(onboardingStatusService)  // Add this
            .environment(authViewModel)
            .environment(themeManager)
            .environment(insightsViewModel)
            .environment(syncStatusViewModel)
            .environment(syncHistoryStore)
            .environment(\.supabaseService, supabaseService)
            .environment(\.apiClient, apiClient)
            .environment(\.foundationModelService, foundationModelService)
            .preferredColorScheme(isUITestingDarkMode ? .dark : themeManager.currentTheme.colorScheme)
    }
    .modelContainer(sharedModelContainer)
}
```

4. Also handle screenshot mode - update the DEBUG block to use RootView pattern:
- For screenshot mode, you may need to set appRouter to .authenticated directly

IMPORTANT: The `appRouter.determineInitialRoute()` call MUST happen in init(), NOT in a Task or onAppear. This ensures synchronous route determination before SwiftUI renders body.
  </action>
  <verify>
Build succeeds: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | tail -20`
  </verify>
  <done>
trendyApp creates AppRouter in init() and calls determineInitialRoute() synchronously before body renders.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds without errors
2. AppRouter.determineInitialRoute() has no `async` keyword
3. trendyApp calls appRouter.determineInitialRoute() in init() (not in Task)
4. RootView switches on router.currentRoute
5. Environment injection chain: trendyApp -> RootView -> AppRouter
</verification>

<success_criteria>
- [ ] AppRouter created with AppRoute enum (loading, onboarding, login, authenticated)
- [ ] determineInitialRoute() is synchronous (no async/await in signature)
- [ ] RootView displays different views based on route state
- [ ] trendyApp creates and wires AppRouter in init()
- [ ] determineInitialRoute() called synchronously before body renders
- [ ] All files build without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-ios-state-architecture/09-02-SUMMARY.md`
</output>
