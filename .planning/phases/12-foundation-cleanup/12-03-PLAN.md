---
phase: 12-foundation-cleanup
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/Services/Sync/SyncEngine.swift
autonomous: true

must_haves:
  truths:
    - "Cursor fallback uses Int64.max/2 instead of 1_000_000_000"
    - "Property type fallback errors are logged with full context"
    - "All cursor state changes log before/after values"
    - "Busy-wait polling replaced with continuation-based waiting with timeout"
  artifacts:
    - path: "apps/ios/trendy/Services/Sync/SyncEngine.swift"
      provides: "SyncEngine with hardened cursor, logging, and async waiting"
      contains: "Int64.max / 2"
  key_links:
    - from: "SyncEngine.swift"
      to: "Logger.swift"
      via: "property type fallback logging"
      pattern: "Log\\.sync\\.warning.*property"
---

<objective>
Harden SyncEngine with safer cursor fallback, property type fallback logging, enhanced cursor state logging, and continuation-based waiting

Purpose: Fix silent errors and improve debuggability of sync operations. The cursor fallback prevents theoretical overflow issues. Property type fallback logging surfaces data issues. Cursor state logging enables debugging sync state. Continuation-based waiting eliminates CPU waste.

Output: SyncEngine.swift with four improvements for reliability and observability
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-foundation-cleanup/12-CONTEXT.md
@.planning/phases/12-foundation-cleanup/12-RESEARCH.md
@apps/ios/trendy/Services/Sync/SyncEngine.swift
@apps/ios/trendy/Utilities/Logger.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix cursor fallback and add property type fallback logging</name>
  <files>apps/ios/trendy/Services/Sync/SyncEngine.swift</files>
  <action>
**1. Fix cursor fallback value (line ~273):**

Change:
```swift
lastSyncCursor = 1_000_000_000
```

To:
```swift
// Use Int64.max / 2 to avoid any theoretical overflow concerns
// This value (~4.6 quintillion) is far enough in the future
lastSyncCursor = Int64.max / 2
```

Update the log message context to show the new fallback value.

**2. Add property type fallback logging (3 locations):**

At lines ~1460, ~1680, ~1810, find patterns like:
```swift
propDef.propertyType = PropertyType(rawValue: propertyType) ?? .text
```

Replace with:
```swift
if let parsedType = PropertyType(rawValue: propertyType) {
    propDef.propertyType = parsedType
} else {
    Log.sync.warning("Unknown property type, using fallback", context: .with { ctx in
        ctx.add("raw_value", propertyType)
        ctx.add("fallback", PropertyType.text.rawValue)
        ctx.add("property_key", propDef.key)
    })
    #if DEBUG
    // Developer indicator for silent failures
    assertionFailure("Unknown PropertyType: \(propertyType)")
    #endif
    propDef.propertyType = .text
}
```

The three locations:
- Line ~1460: Change feed property parsing (in applyUpsert)
- Line ~1680: Bootstrap property parsing (in bootstrapFetch)
- Line ~1810: API property conversion (in convertAPIProperties)

For the static convertAPIProperties function, adapt the pattern since it doesn't have logging context readily available. Create a helper or log inline.
  </action>
  <verify>
1. `grep "Int64.max / 2" apps/ios/trendy/Services/Sync/SyncEngine.swift` returns match
2. `grep -c "Unknown property type" apps/ios/trendy/Services/Sync/SyncEngine.swift` returns 3 (or 2 if convertAPIProperties handled differently)
3. `grep "1_000_000_000" apps/ios/trendy/Services/Sync/SyncEngine.swift` returns no match
4. Build succeeds
  </verify>
  <done>Cursor fallback uses safe value, property type fallbacks logged with context and DEBUG assertion</done>
</task>

<task type="auto">
  <name>Task 2: Enhance cursor state change logging with before/after values</name>
  <files>apps/ios/trendy/Services/Sync/SyncEngine.swift</files>
  <action>
Add before/after cursor values to all cursor state changes. Research shows 6 locations need enhancement:

**1. Init load (line ~116):**
Already has logging. Verify it shows the loaded cursor value.

**2. Bootstrap success (lines ~259-269):**
Already has good logging with cursor value. Add "before" value for comparison:
```swift
let previousCursor = lastSyncCursor
let latestCursor = try await apiClient.getLatestCursor()
lastSyncCursor = latestCursor
// ... existing save code ...
Log.sync.info("Cursor saved after bootstrap", context: .with { ctx in
    ctx.add("before", Int(previousCursor))
    ctx.add("after", Int(latestCursor))
    ctx.add("cursor_key", cursorKey)
    // ... existing fields ...
})
```

**3. Bootstrap fallback (lines ~273-279):**
Add before value:
```swift
let previousCursor = lastSyncCursor
lastSyncCursor = Int64.max / 2
Log.sync.warning("Could not get latest cursor, using fallback", context: .with { ctx in
    ctx.add("before", Int(previousCursor))
    ctx.add("after", Int(lastSyncCursor))
    // ... existing fields ...
})
```

**4. Force reset (lines ~373-374):**
This sets cursor to 0 for full resync. Add before/after:
```swift
let previousCursor = lastSyncCursor
lastSyncCursor = 0
UserDefaults.standard.set(0, forKey: cursorKey)
Log.sync.info("Cursor reset for forced resync", context: .with { ctx in
    ctx.add("before", Int(previousCursor))
    ctx.add("after", 0)
})
```

**5. Skip to latest (lines ~403-410):**
Already logs new cursor. Add before value:
```swift
let previousCursor = lastSyncCursor
lastSyncCursor = latestCursor
Log.sync.info("Skipped to latest cursor", context: .with { ctx in
    ctx.add("before", Int(previousCursor))
    ctx.add("after", Int(latestCursor))
    // ... existing fields ...
})
```

**6. Pull changes (lines ~1268-1270):**
This increments cursor during pagination. Add before/after:
```swift
if response.nextCursor > lastSyncCursor {
    let previousCursor = lastSyncCursor
    lastSyncCursor = response.nextCursor
    UserDefaults.standard.set(Int(lastSyncCursor), forKey: cursorKey)
    Log.sync.debug("Cursor advanced", context: .with { ctx in
        ctx.add("before", Int(previousCursor))
        ctx.add("after", Int(lastSyncCursor))
    })
}
```
  </action>
  <verify>
1. `grep -c "before" apps/ios/trendy/Services/Sync/SyncEngine.swift | grep -v "//"` shows increased count (at least 5 new occurrences in cursor logging)
2. Search for cursor log messages and verify they include before/after context
3. Build succeeds
  </verify>
  <done>All cursor state changes log before/after values for debugging</done>
</task>

<task type="auto">
  <name>Task 3: Replace busy-wait polling with continuation-based waiting</name>
  <files>apps/ios/trendy/Services/Sync/SyncEngine.swift</files>
  <action>
Replace the busy-wait polling in forceFullResync (lines ~367-370):

**Current code:**
```swift
// If a sync is already running, wait for it to complete
while isSyncing {
    Log.sync.debug("Waiting for in-progress sync to complete...")
    try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
}
```

**Replacement using withThrowingTaskGroup for timeout:**

1. Add a SyncError case for timeout:
```swift
enum SyncError: LocalizedError {
    case encodingFailed
    case waitTimeout
    case unknown(String)

    var errorDescription: String? {
        switch self {
        case .encodingFailed:
            return "Failed to encode mutation payload"
        case .waitTimeout:
            return "Timed out waiting for sync to complete"
        case .unknown(let message):
            return message
        }
    }
}
```

2. Create a private helper method:
```swift
/// Wait for any in-progress sync to complete, with timeout.
/// Uses continuation-based waiting instead of busy-wait polling.
private func waitForSyncCompletion(timeout: Duration = .seconds(30)) async throws {
    guard isSyncing else { return }

    Log.sync.debug("Waiting for in-progress sync to complete", context: .with { ctx in
        ctx.add("timeout_seconds", 30)
    })

    try await withThrowingTaskGroup(of: Void.self) { group in
        // Task 1: Poll for sync completion (still polls, but with cancellation support)
        group.addTask { [self] in
            while await self.isSyncing {
                try Task.checkCancellation()
                try await Task.sleep(for: .milliseconds(50))
            }
        }

        // Task 2: Timeout after specified duration
        group.addTask {
            try await Task.sleep(until: .now + timeout, clock: .continuous)
            throw SyncError.waitTimeout
        }

        // Wait for first task to complete, cancel the other
        defer { group.cancelAll() }
        try await group.next()
    }

    Log.sync.debug("In-progress sync completed, proceeding")
}
```

3. Update forceFullResync to use the helper:
```swift
func forceFullResync() async {
    Log.sync.info("Force full resync requested")

    // Wait for any in-progress sync with timeout
    do {
        try await waitForSyncCompletion(timeout: .seconds(30))
    } catch {
        Log.sync.warning("Timeout waiting for sync, proceeding anyway", context: .with { ctx in
            ctx.add(error: error)
        })
    }

    // Reset cursor and set flag to force bootstrap
    let previousCursor = lastSyncCursor
    lastSyncCursor = 0
    UserDefaults.standard.set(0, forKey: cursorKey)
    forceBootstrapOnNextSync = true

    Log.sync.info("Cursor reset for forced resync", context: .with { ctx in
        ctx.add("before", Int(previousCursor))
        ctx.add("after", 0)
    })

    await performSync()
}
```

Note: The inner polling loop still exists but now:
- Has cancellation support via Task.checkCancellation()
- Has a timeout to prevent infinite waiting
- Uses shorter sleep intervals (50ms vs 100ms)
- Is properly structured for Swift Concurrency
  </action>
  <verify>
1. `grep "while isSyncing" apps/ios/trendy/Services/Sync/SyncEngine.swift` shows the pattern only inside the withThrowingTaskGroup helper (not raw busy-wait)
2. `grep "waitForSyncCompletion" apps/ios/trendy/Services/Sync/SyncEngine.swift` returns matches
3. `grep "SyncError.waitTimeout" apps/ios/trendy/Services/Sync/SyncEngine.swift` returns match
4. Build succeeds
  </verify>
  <done>Busy-wait polling replaced with continuation-based waiting with 30s timeout</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify cursor fallback safety:
```bash
grep "Int64.max / 2" apps/ios/trendy/Services/Sync/SyncEngine.swift
grep "1_000_000_000" apps/ios/trendy/Services/Sync/SyncEngine.swift  # Should return nothing
```

2. Verify property type fallback logging:
```bash
grep -c "Unknown property type" apps/ios/trendy/Services/Sync/SyncEngine.swift
```

3. Verify cursor before/after logging:
```bash
grep -A2 "Cursor" apps/ios/trendy/Services/Sync/SyncEngine.swift | grep -c "before"
```

4. Verify continuation-based waiting:
```bash
grep "waitForSyncCompletion" apps/ios/trendy/Services/Sync/SyncEngine.swift
grep "withThrowingTaskGroup" apps/ios/trendy/Services/Sync/SyncEngine.swift
```

5. Verify build succeeds:
```bash
cd apps/ios && xcodebuild -scheme "Trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16" build 2>&1 | grep -E "(BUILD|error:)"
```
</verification>

<success_criteria>
- [ ] Cursor fallback uses Int64.max / 2 instead of 1_000_000_000
- [ ] Property type fallbacks logged at 3 locations with raw_value, fallback, property_key
- [ ] DEBUG builds hit assertionFailure on unknown property types
- [ ] All 6 cursor state changes log before/after values
- [ ] Busy-wait replaced with continuation-based waitForSyncCompletion helper
- [ ] Timeout error case added to SyncError enum
- [ ] iOS app builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/12-foundation-cleanup/12-03-SUMMARY.md`
</output>
