---
phase: 05-sync-engine
plan: 05
type: execute
wave: 3
depends_on: [05-01, 05-02]
files_modified:
  - apps/ios/trendy/Services/Sync/SyncEngine.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "pendingCount reflects actual PendingMutation count on app launch"
    - "pendingDeleteIds survives app restart"
    - "Deleted events do not reappear after restart (no resurrection)"
    - "Sync banner shows pending count immediately after restart"
  artifacts:
    - path: "apps/ios/trendy/Services/Sync/SyncEngine.swift"
      provides: "State loading on init and persistent pendingDeleteIds"
      contains: "loadPendingState|loadPendingCount|pendingDeleteIds.*UserDefaults"
  key_links:
    - from: "SyncEngine.init"
      to: "pendingCount"
      via: "Load from SwiftData on init"
      pattern: "init.*\\{[\\s\\S]*?fetchCount.*PendingMutation"
    - from: "pendingDeleteIds"
      to: "UserDefaults"
      via: "Persist and load"
      pattern: "UserDefaults.*pendingDeleteIds"
---

<objective>
Fix state persistence to prevent pending count loss and delete resurrection on restart.

Purpose: Currently SyncEngine.pendingCount starts at 0 and pendingDeleteIds is in-memory only. After app restart, the sync banner never shows pending mutations and deleted events reappear (resurrection bug). This violates phase goals "sync state visibility" and "never loses data."

Output: SyncEngine that loads pendingCount and pendingDeleteIds on init, ensuring UI correctly reflects pending state and deleted events stay deleted across restarts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sync-engine/05-VERIFICATION.md
@apps/ios/trendy/Services/Sync/SyncEngine.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Load pendingCount on SyncEngine init</name>
  <files>apps/ios/trendy/Services/Sync/SyncEngine.swift</files>
  <action>
Modify SyncEngine.init() to load pendingCount from SwiftData:

1. The challenge: init() is not async, but fetching from SwiftData requires ModelContext

2. Solution: Create a helper method `loadInitialPendingCount()` and call it synchronously in init using the modelContainer:
```swift
init(apiClient: APIClient, modelContainer: ModelContainer) {
    self.apiClient = apiClient
    self.modelContainer = modelContainer
    // ... existing cursor loading ...

    // Load pending count synchronously from SwiftData
    let context = ModelContext(modelContainer)
    let descriptor = FetchDescriptor<PendingMutation>()
    let count = (try? context.fetchCount(descriptor)) ?? 0

    // Note: Can't use Task here because pendingCount is @MainActor
    // Instead, we'll set the count immediately via a sync pattern
}
```

3. Problem: pendingCount is `@MainActor` but init is not on MainActor. Two options:

   Option A (PREFERRED): Move initial count to a lazy load pattern
   - Add private var `_initialPendingCountLoaded = false`
   - In `updatePendingCount()` check if first call and load from SwiftData
   - On first access via EventStore, it will trigger load

   Option B: Use Task to set on MainActor after init
   - In init, spawn Task { @MainActor in self.pendingCount = count }
   - Risk: UI might briefly show 0 before Task runs

4. Implement Option A:
   - Add `private var initialStateLoaded = false`
   - Modify `updatePendingCount()` to be called on first access
   - Add public `loadInitialState()` async method called by EventStore.setModelContext()

5. In EventStore.setModelContext(), after setting syncEngine, call:
```swift
await syncEngine.loadInitialState()
```

6. Log the loaded count for debugging
  </action>
  <verify>Build succeeds and grep shows loadInitialState in SyncEngine: `grep -n "loadInitialState\|initialStateLoaded" /Users/cipher/Repositories/trendy/apps/ios/trendy/Services/Sync/SyncEngine.swift`</verify>
  <done>pendingCount loaded from SwiftData on app launch via loadInitialState()</done>
</task>

<task type="auto">
  <name>Task 2: Persist pendingDeleteIds to UserDefaults</name>
  <files>apps/ios/trendy/Services/Sync/SyncEngine.swift</files>
  <action>
Make pendingDeleteIds survive app restarts by persisting to UserDefaults:

1. Add UserDefaults key constant:
```swift
private var pendingDeleteIdsKey: String {
    "sync_engine_pending_delete_ids_\(AppEnvironment.current.rawValue)"
}
```

2. Load on init (or in loadInitialState):
```swift
// Load pending delete IDs
if let savedIds = UserDefaults.standard.array(forKey: pendingDeleteIdsKey) as? [String] {
    pendingDeleteIds = Set(savedIds)
    Log.sync.info("Loaded pendingDeleteIds", context: .with { ctx in
        ctx.add("count", savedIds.count)
    })
}
```

3. Add helper to persist when modified:
```swift
private func savePendingDeleteIds() {
    UserDefaults.standard.set(Array(pendingDeleteIds), forKey: pendingDeleteIdsKey)
}
```

4. Call savePendingDeleteIds() in these locations:
   - After adding IDs in `performSync()` (line ~134 where pendingDeleteIds is set)
   - After removing IDs when delete mutation succeeds

5. Find where delete mutations are processed (in flushPendingMutations) and ensure:
   - On successful delete sync, remove ID from pendingDeleteIds
   - Call savePendingDeleteIds() after removal

6. Alternative approach: Instead of persisting pendingDeleteIds, check PendingMutation table for .delete operations in pullChanges. This is simpler because:
   - PendingMutation already persists delete operations
   - In pullChanges, query for pending deletes before upserting
   - This is more reliable and doesn't require separate storage

7. Implement the alternative (check PendingMutation for deletes):
   - In pullChanges(), before calling applyUpsert, query PendingMutation for .delete operations
   - Build pendingDeleteIds from that query instead of relying on in-memory state
   - This ensures resurrection prevention works even after restart
  </action>
  <verify>Build succeeds and grep shows pendingDeleteIds persistence or PendingMutation check in pullChanges: `grep -n "pendingDelete\|PendingMutation.*delete" /Users/cipher/Repositories/trendy/apps/ios/trendy/Services/Sync/SyncEngine.swift | head -30`</verify>
  <done>pendingDeleteIds either persisted to UserDefaults OR dynamically rebuilt from PendingMutation table in pullChanges</done>
</task>

<task type="auto">
  <name>Task 3: Wire EventStore to call loadInitialState</name>
  <files>apps/ios/trendy/ViewModels/EventStore.swift</files>
  <action>
Ensure EventStore triggers state loading when SyncEngine is ready:

1. In EventStore.setModelContext() (or wherever syncEngine is set), add call to load initial state:
```swift
if let syncEngine = syncEngine {
    await syncEngine.loadInitialState()
}
```

2. This should happen BEFORE `refreshSyncStateForUI()` so the count is accurate when UI refreshes

3. Find the location where syncEngine is configured (likely in setModelContext or init) and add the call

4. The flow should be:
   - App launches
   - EventStore.setModelContext() called with modelContainer
   - SyncEngine initialized
   - `await syncEngine.loadInitialState()` called
   - pendingCount now reflects actual PendingMutation count
   - refreshSyncStateForUI() updates cached properties
   - UI shows correct pending count
  </action>
  <verify>Build succeeds: `cd /Users/cipher/Repositories/trendy && xcodebuild -project apps/ios/trendy.xcodeproj -scheme "trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16 Pro" build 2>&1 | tail -20`</verify>
  <done>EventStore calls loadInitialState() on sync engine setup, pendingCount accurate on launch</done>
</task>

</tasks>

<verification>
After all tasks:
1. Build succeeds without errors
2. SyncEngine.loadInitialState() exists and is called from EventStore
3. pendingCount is loaded from SwiftData on app launch
4. pendingDeleteIds either persisted to UserDefaults OR rebuilt from PendingMutation in pullChanges
5. No resurrection of deleted events after app restart
</verification>

<success_criteria>
- App restart shows correct pending count in banner (not 0)
- Deleted events stay deleted after restart and sync
- pendingDeleteIds survives restart (via persistence or dynamic query)
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-sync-engine/05-05-SUMMARY.md`
</output>
