---
phase: 05-sync-engine
plan: 04
type: execute
wave: 3
depends_on: [05-01, 05-02]
files_modified:
  - apps/ios/trendy/ViewModels/EventStore.swift
  - apps/ios/trendy/Services/Sync/SyncEngine.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Mutations are queued BEFORE or atomically WITH entity saves"
    - "Force quit after entity save but before sync does NOT lose the mutation"
    - "PendingMutation exists for every unsynced entity"
  artifacts:
    - path: "apps/ios/trendy/ViewModels/EventStore.swift"
      provides: "Atomic mutation queueing in CRUD operations"
      contains: "queueMutation.*before.*save|atomic"
    - path: "apps/ios/trendy/Services/Sync/SyncEngine.swift"
      provides: "Synchronous mutation creation option"
  key_links:
    - from: "EventStore.recordEvent"
      to: "SyncEngine.queueMutation"
      via: "Call queueMutation BEFORE modelContext.save()"
      pattern: "queueMutation.*\\n.*modelContext\\.save"
---

<objective>
Fix mutation atomicity to prevent data loss on force quit.

Purpose: The current implementation queues mutations AFTER entity saves. A force quit between save() and queueMutation() loses the mutation, violating the phase goal "never loses data."

Output: Modified EventStore CRUD methods that queue mutations BEFORE saving entities, ensuring PendingMutation always exists when entity exists.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sync-engine/05-VERIFICATION.md
@apps/ios/trendy/ViewModels/EventStore.swift
@apps/ios/trendy/Services/Sync/SyncEngine.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reorder recordEvent to queue mutation first</name>
  <files>apps/ios/trendy/ViewModels/EventStore.swift</files>
  <action>
In `recordEvent()` (around lines 475-540):

1. Move the mutation queueing block BEFORE `modelContext.save()`:
   - Create the `CreateEventRequest` and encode payload BEFORE save
   - Call `syncEngine.queueMutation()` BEFORE `modelContext.save()`
   - This ensures PendingMutation is persisted even if save() is interrupted

2. Current (WRONG):
```swift
modelContext.insert(newEvent)
try modelContext.save()  // (1) Entity saved
// FORCE QUIT HERE = MUTATION LOST
try await syncEngine.queueMutation(...)  // (2) Mutation queued after
```

3. Fixed (CORRECT):
```swift
modelContext.insert(newEvent)
if let syncEngine = syncEngine {
    let request = CreateEventRequest(...)
    let payload = try JSONEncoder().encode(request)
    try await syncEngine.queueMutation(...)  // (1) Mutation queued first
}
try modelContext.save()  // (2) Entity + mutation both committed
```

4. Keep the `performSync()` call AFTER save (sync can fail, but data is safe)

5. Handle the error case: if queueMutation fails, still save locally (user's event shouldn't be lost just because queue failed)
  </action>
  <verify>Build succeeds: `cd /Users/cipher/Repositories/trendy && xcodebuild -project apps/ios/trendy.xcodeproj -scheme "trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16 Pro" build 2>&1 | tail -20`</verify>
  <done>recordEvent() queues mutation BEFORE modelContext.save()</done>
</task>

<task type="auto">
  <name>Task 2: Reorder updateEvent to queue mutation first</name>
  <files>apps/ios/trendy/ViewModels/EventStore.swift</files>
  <action>
In `updateEvent()` (around lines 543-607):

1. Move the mutation queueing block BEFORE `modelContext.save()`:
   - Build the `UpdateEventRequest` BEFORE save
   - Call `syncEngine.queueMutation()` BEFORE `modelContext.save()`

2. Current pattern (lines 565-600):
```swift
try modelContext.save()  // Save first
// FORCE QUIT HERE = MUTATION LOST
if let syncEngine = syncEngine {
    try await syncEngine.queueMutation(...)  // Queue after
}
```

3. Fixed pattern:
```swift
if let syncEngine = syncEngine {
    let request = UpdateEventRequest(...)
    let payload = try JSONEncoder().encode(request)
    try await syncEngine.queueMutation(...)  // Queue first
}
try modelContext.save()  // Save after (both entity update + mutation committed)
```

4. Calendar update stays BEFORE queueMutation (calendar is external, order doesn't matter for data safety)

5. Handle error: if queueMutation throws, still save locally
  </action>
  <verify>Build succeeds: `cd /Users/cipher/Repositories/trendy && xcodebuild -project apps/ios/trendy.xcodeproj -scheme "trendy (Local)" -destination "platform=iOS Simulator,name=iPhone 16 Pro" build 2>&1 | tail -20`</verify>
  <done>updateEvent() queues mutation BEFORE modelContext.save()</done>
</task>

<task type="auto">
  <name>Task 3: Fix deleteEvent ordering (already correct but verify)</name>
  <files>apps/ios/trendy/ViewModels/EventStore.swift</files>
  <action>
In `deleteEvent()` (around lines 607-655):

1. VERIFY the current order is correct (it should be):
   - queueMutation() is called BEFORE modelContext.delete()
   - This is correct for deletes because we need the entity to still exist when queueing

2. However, the save() is AFTER delete, and there's a potential issue:
   - If queueMutation fails, we still delete locally - this is OK
   - But if app crashes after queueMutation but before delete, we'll have a pending DELETE mutation for an entity that still exists locally

3. The current pattern is actually correct for deletes because:
   - Queue deletion first (so mutation exists)
   - Delete entity
   - Save (commits both deletion + mutation was already saved in queueMutation)

4. Verify no changes needed but add a comment explaining the ordering is intentional for deletes

5. Apply same pattern to createEventType(), updateEventType(), deleteEventType(), createGeofence(), updateGeofence(), deleteGeofence() if they exist
  </action>
  <verify>Grep for all queueMutation calls and verify order: `grep -n -B5 "queueMutation" /Users/cipher/Repositories/trendy/apps/ios/trendy/ViewModels/EventStore.swift | head -100`</verify>
  <done>All CRUD operations queue mutations BEFORE entity saves; delete ordering verified as correct</done>
</task>

</tasks>

<verification>
After all tasks:
1. Build succeeds without errors
2. All queueMutation calls come BEFORE modelContext.save() for creates/updates
3. Delete mutations are queued while entity still exists
4. No data loss window between entity save and mutation queue
</verification>

<success_criteria>
- recordEvent(), updateEvent() queue mutations BEFORE save
- deleteEvent() queue order verified as correct (mutation before delete)
- Build passes
- Force quit between entity insert and sync cannot lose the mutation
</success_criteria>

<output>
After completion, create `.planning/phases/05-sync-engine/05-04-SUMMARY.md`
</output>
