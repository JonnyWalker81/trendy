---
phase: 01-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/Services/HealthKitError.swift
  - apps/ios/trendy/Services/HealthKitService.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "HealthKit operations that can fail propagate errors to callers"
    - "Callers can distinguish between different failure modes"
  artifacts:
    - path: "apps/ios/trendy/Services/HealthKitError.swift"
      provides: "Custom error enum for HealthKit operations"
      exports: ["HealthKitError"]
    - path: "apps/ios/trendy/Services/HealthKitService.swift"
      provides: "Error-throwing methods for critical operations"
      contains: "throws.*HealthKitError"
  key_links:
    - from: "HealthKitService.swift catch blocks"
      to: "HealthKitError cases"
      via: "throw HealthKitError.*"
      pattern: "throw HealthKitError\\."
---

<objective>
Close verification gap: HealthKit error handling logs but doesn't propagate errors to callers.

Purpose: Critical operations (event saving, background delivery setup) should throw errors so callers can handle failures appropriately (retry, notify user, graceful degradation).

Output: HealthKitError enum and updated HealthKitService methods that throw for critical failures.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-foundation-VERIFICATION.md

Source files:
@apps/ios/trendy/Services/HealthKitService.swift
@apps/ios/trendy/Models/EventError.swift — existing error pattern to follow
@apps/ios/trendy/Services/APIClient.swift — existing error pattern (APIError)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HealthKitError enum</name>
  <files>apps/ios/trendy/Services/HealthKitError.swift</files>
  <action>
Create a new file `HealthKitError.swift` in Services/ with a `HealthKitError` enum conforming to `LocalizedError`.

Cases to include based on verification gap analysis:
- `authorizationFailed(Error)` - HKHealthStore.requestAuthorization threw
- `backgroundDeliveryFailed(String, Error)` - enableBackgroundDelivery threw (String = category name)
- `eventSaveFailed(Error)` - modelContext.insert/save threw
- `eventLookupFailed(Error)` - modelContext.fetch threw
- `eventUpdateFailed(Error)` - updating existing event failed

Follow existing pattern from EventError.swift:
- Implement `errorDescription: String?`
- Implement `recoverySuggestion: String?`
- Include underlying error in associated value for debugging

Do NOT add cases for non-critical operations (like checking if event exists - those can return false on error).
  </action>
  <verify>File exists, compiles: `swiftc -parse apps/ios/trendy/Services/HealthKitError.swift` (requires mocking imports)</verify>
  <done>HealthKitError.swift created with 5 cases, LocalizedError conformance, errorDescription and recoverySuggestion</done>
</task>

<task type="auto">
  <name>Task 2: Update critical HealthKitService methods to throw</name>
  <files>apps/ios/trendy/Services/HealthKitService.swift</files>
  <action>
Update these methods to propagate errors via throws:

**1. requestAuthorization(for:)** (line ~382)
- Current: catch -> log -> continue silently
- Change: Remove catch block, let error propagate OR add `throws` and rethrow as `HealthKitError.authorizationFailed(error)`
- Note: Caller must handle - this is critical for app functionality

**2. enableBackgroundDelivery(for:)** (line ~483)
- Current: catch -> log -> continue silently
- Change: Add `throws`, rethrow as `HealthKitError.backgroundDeliveryFailed(category.displayName, error)`
- Note: Caller should know if background delivery failed to set up

**3. saveEvent(for:sample:data:)** (line ~1268)
- Current: catch -> log -> continue silently
- Change: Add `throws`, rethrow as `HealthKitError.eventSaveFailed(error)`
- Note: This is DATA LOSS risk - caller MUST know if save failed

**4. updateHealthKitEvent(_:with:)** (line ~1376)
- Current: catch -> log -> continue
- Change: Add `throws`, rethrow as `HealthKitError.eventUpdateFailed(error)`
- Note: DATA LOSS risk - caller must know

**5. createOrGetEventType(for:)** (line ~1427)
- Current: catch -> log -> return nil
- Keep as-is: Returning nil is acceptable for "get or create" pattern; caller checks for nil

**DO NOT CHANGE these methods (returning false/nil on error is acceptable):**
- `eventExistsInDatabase(for:at:)` - returning false allows new event creation
- `workoutExistsByTimestamp(...)` - returning false allows new event creation
- `findHealthKitEvent(by:)` - returning nil is expected for "not found"

Import HealthKitError at top of file.
  </action>
  <verify>
1. `swiftc -parse apps/ios/trendy/Services/HealthKitService.swift` succeeds (syntax check)
2. Grep for "throw HealthKitError" shows 4+ occurrences
3. Grep for "catch {" - verify reduced count for critical operations
  </verify>
  <done>
- requestAuthorization throws HealthKitError.authorizationFailed
- enableBackgroundDelivery throws HealthKitError.backgroundDeliveryFailed
- saveEvent throws HealthKitError.eventSaveFailed
- updateHealthKitEvent throws HealthKitError.eventUpdateFailed
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] HealthKitError.swift exists with LocalizedError conformance
- [ ] HealthKitService.swift imports HealthKitError
- [ ] 4 critical methods now throw appropriate HealthKitError cases
- [ ] Non-critical methods (eventExistsInDatabase, findHealthKitEvent) unchanged
- [ ] Swift syntax check passes: `swiftc -parse` on both files
</verification>

<success_criteria>
- HealthKitError enum created with 5 cases
- 4 critical HealthKitService methods converted to throwing
- Error propagation enables callers to handle failures
- No data loss risk from silent failures in event save/update
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
