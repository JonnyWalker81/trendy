---
phase: 01-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/Services/GeofenceError.swift
  - apps/ios/trendy/Services/GeofenceManager.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Geofence operations that can fail propagate errors to callers"
    - "Callers can distinguish between different geofence failure modes"
  artifacts:
    - path: "apps/ios/trendy/Services/GeofenceError.swift"
      provides: "Custom error enum for Geofence operations"
      exports: ["GeofenceError"]
    - path: "apps/ios/trendy/Services/GeofenceManager.swift"
      provides: "Error-throwing methods for critical operations"
      contains: "throws.*GeofenceError"
  key_links:
    - from: "GeofenceManager.swift catch blocks"
      to: "GeofenceError cases"
      via: "throw GeofenceError.*"
      pattern: "throw GeofenceError\\."
---

<objective>
Close verification gap: Geofence error handling logs but doesn't propagate errors to callers.

Purpose: Critical operations (saving geofence events) should throw errors so callers know when data capture failed. This is especially important for geofence events since they represent real-world user movements.

Output: GeofenceError enum and updated GeofenceManager methods that throw for critical failures.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-foundation-VERIFICATION.md

Source files:
@apps/ios/trendy/Services/GeofenceManager.swift
@apps/ios/trendy/Models/EventError.swift â€” existing error pattern to follow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GeofenceError enum</name>
  <files>apps/ios/trendy/Services/GeofenceError.swift</files>
  <action>
Create a new file `GeofenceError.swift` in Services/ with a `GeofenceError` enum conforming to `LocalizedError`.

Cases to include based on verification gap analysis:
- `entryEventSaveFailed(String, Error)` - Failed to save geofence entry event (String = geofence name)
- `exitEventSaveFailed(String, Error)` - Failed to save geofence exit event (String = geofence name)
- `geofenceNotFound(String)` - Geofence lookup failed (String = identifier)
- `eventTypeMissing(String)` - EventType not found for geofence (String = geofence name)

Follow existing pattern from EventError.swift:
- Implement `errorDescription: String?`
- Implement `recoverySuggestion: String?`
- Include underlying error in associated value for debugging

Keep it focused - GeofenceManager has fewer error cases than HealthKitService.
  </action>
  <verify>File exists and syntax is valid</verify>
  <done>GeofenceError.swift created with 4 cases, LocalizedError conformance, errorDescription and recoverySuggestion</done>
</task>

<task type="auto">
  <name>Task 2: Update GeofenceManager methods to throw</name>
  <files>apps/ios/trendy/Services/GeofenceManager.swift</files>
  <action>
Update these methods to propagate errors via throws:

**1. handleRegionEntry(_:) / processGeofenceEntry(_:)** (line ~498)
- Current: catch -> log "Failed to save geofence entry event" -> continue
- Issue: Entry events represent user arriving at a location - DATA LOSS risk
- Change: The inner save operation should throw `GeofenceError.entryEventSaveFailed(geofence.name, error)`
- Note: This may require restructuring - the catch block is inside a Task. Consider propagating error via completion handler or making the outer method async throws.

**2. handleRegionExit(_:) / processGeofenceExit(_:)** (line ~589)
- Current: catch -> log "Failed to save geofence exit event" -> continue
- Issue: Exit events represent user leaving a location - DATA LOSS risk
- Change: The save operation should throw `GeofenceError.exitEventSaveFailed(geofence.name, error)`

**Approach for async Task blocks:**
If the catch block is inside a `Task { }`, the error can't be thrown directly. Options:
1. Make the enclosing method `async throws` and await the task
2. Use a completion handler with Result type
3. Store the error and surface it via a published property that UI can observe

Recommended: Add a `@Published var lastError: GeofenceError?` property that gets set on failure. This allows UI to react to geofence failures without changing the CLLocationManagerDelegate contract.

Import GeofenceError at top of file.
  </action>
  <verify>
1. `swiftc -parse apps/ios/trendy/Services/GeofenceManager.swift` succeeds
2. Either: throw statements added OR @Published var lastError property added
3. Grep confirms GeofenceError is used in error handling paths
  </verify>
  <done>
- Entry event save failure surfaces via throw or @Published lastError
- Exit event save failure surfaces via throw or @Published lastError
- Callers/UI can now detect and handle geofence event save failures
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] GeofenceError.swift exists with LocalizedError conformance
- [ ] GeofenceManager.swift imports GeofenceError
- [ ] Entry and exit event save failures are no longer silent
- [ ] Error is either thrown or surfaced via observable property
- [ ] Swift syntax check passes
</verification>

<success_criteria>
- GeofenceError enum created with 4 cases
- Geofence entry/exit event save failures are no longer silent
- Errors are surfaced to callers via throws or @Published property
- No data loss risk from silent failures in geofence event save
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
