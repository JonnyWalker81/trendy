---
phase: 17-unit-tests-circuit-breaker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift
autonomous: true

must_haves:
  truths:
    - "Test verifies circuit breaker trips after 3 consecutive rate limit errors"
    - "Test verifies circuit breaker resets after backoff period expires"
    - "Test verifies sync blocked while circuit breaker tripped"
    - "Test verifies exponential backoff timing progression"
    - "Test verifies rate limit counter resets on successful sync"
  artifacts:
    - path: "apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift"
      provides: "Circuit breaker unit tests"
      min_lines: 250
      exports: ["CircuitBreakerTests @Suite"]
  key_links:
    - from: "CircuitBreakerTests.swift"
      to: "MockNetworkClient"
      via: "response queue configuration"
      pattern: "createEventsBatchResponses.*failure.*httpError.*429"
    - from: "CircuitBreakerTests.swift"
      to: "MockDataStore"
      via: "seedPendingMutation"
      pattern: "seedPendingMutation.*entityType.*event"
    - from: "CircuitBreakerTests.swift"
      to: "SyncEngine"
      via: "isCircuitBreakerTripped property"
      pattern: "isCircuitBreakerTripped"
---

<objective>
Create comprehensive unit tests for SyncEngine's circuit breaker behavior.

Purpose: Verify rate limit handling trips and resets correctly to prevent runaway API calls during outages
Output: CircuitBreakerTests.swift with tests covering all 5 CB requirements
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-unit-tests-circuit-breaker/17-RESEARCH.md
@.planning/phases/16-test-infrastructure/16-01-SUMMARY.md
@.planning/phases/16-test-infrastructure/16-02-SUMMARY.md
@apps/ios/trendy/Services/Sync/SyncEngine.swift
@apps/ios/trendyTests/Mocks/MockNetworkClient.swift
@apps/ios/trendyTests/Mocks/MockDataStore.swift
@apps/ios/trendyTests/Mocks/MockDataStoreFactory.swift
@apps/ios/trendyTests/TestSupport.swift
@apps/ios/trendyTests/APIErrorTests.swift (test pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircuitBreakerTests.swift with core trip and reset tests</name>
  <files>apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift</files>
  <action>
Create a new test file using Swift Testing framework (@Test, @Suite, #expect).

**File structure:**
```
apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift
```

**Required imports:**
```swift
import Testing
import Foundation
@testable import trendy
```

**Test setup pattern (fresh per test):**
```swift
// Create fresh mocks and engine for each test
let mockNetwork = MockNetworkClient()
let mockStore = MockDataStore()
let factory = MockDataStoreFactory(mockStore: mockStore)
let engine = SyncEngine(networkClient: mockNetwork, dataStoreFactory: factory)
```

**Critical setup for all tests that call performSync():**
1. Configure health check to pass: `mockNetwork.getEventTypesResponses = [.success([APIModelFixture.makeAPIEventType()])]`
2. Set cursor to non-zero to skip bootstrap: `UserDefaults.standard.set(1000, forKey: "sync_engine_cursor_\(AppEnvironment.current.rawValue)")`
3. Seed pending mutations to trigger flush: `mockStore.seedPendingMutation(...)`

**Required test suites and tests:**

@Suite("Circuit Breaker - Trip Behavior")
- Test: "Circuit breaker trips after 3 consecutive rate limit errors" (CB-01)
  - Seed 3+ pending mutations with `seedPendingMutation(entityType: .event, entityId: "...", operation: .create, payload: ...)`
  - Configure `createEventsBatchResponses` with 3 consecutive `.failure(APIError.httpError(429))`
  - Call `performSync()`
  - Verify `await engine.isCircuitBreakerTripped == true`

- Test: "Circuit breaker does NOT trip after 2 rate limit errors" (edge case)
  - Similar setup with only 2 rate limit errors
  - Verify `await engine.isCircuitBreakerTripped == false`

@Suite("Circuit Breaker - Reset Behavior")
- Test: "Circuit breaker resets after backoff period expires" (CB-02)
  - Trip the circuit breaker (3 rate limits)
  - Verify tripped
  - Check `circuitBreakerBackoffRemaining` is in expected range (25-35s for first trip)
  - Call `resetCircuitBreaker()` to manually reset (simulates time passing)
  - Verify `isCircuitBreakerTripped == false`

- Test: "Rate limit counter resets on successful sync" (CB-05)
  - Seed mutations
  - Configure responses: 2 failures, then success
  - After first sync, counter at 2 (not tripped)
  - Configure 2 more failures
  - After second sync, counter at 2 (reset by success, then +2)
  - Verify NOT tripped (would be tripped at 4 if counter didn't reset)

**Payload creation for pending mutations:**
```swift
let request = APIModelFixture.makeCreateEventRequest(id: "evt-1", eventTypeId: "type-1")
let payload = try! JSONEncoder().encode(request)
mockStore.seedPendingMutation(entityType: .event, entityId: "evt-1", operation: .create, payload: payload)
```

**Avoid:**
- Real time delays (no Task.sleep for backoff)
- Shared SyncEngine between tests
- Accessing private properties (use isCircuitBreakerTripped, circuitBreakerBackoffRemaining)
  </action>
  <verify>
File exists at apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift with @Suite and @Test annotations.
Tests compile when checking syntax (no runtime needed for this verification).
  </verify>
  <done>
CB-01 (trips after 3 errors) and CB-02 (resets after backoff) and CB-05 (counter resets on success) have dedicated tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sync blocking and backoff timing tests</name>
  <files>apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift</files>
  <action>
Add additional test suites to the existing CircuitBreakerTests.swift file.

@Suite("Circuit Breaker - Sync Blocking")
- Test: "Sync blocked while circuit breaker tripped" (CB-03)
  - Trip circuit breaker (3 rate limits)
  - Record call count: `let callsBefore = mockNetwork.createEventsBatchCalls.count`
  - Attempt another sync: `await engine.performSync()`
  - Verify no new batch calls: `mockNetwork.createEventsBatchCalls.count == callsBefore`
  - This proves sync was blocked

- Test: "Sync allowed after circuit breaker reset"
  - Trip circuit breaker
  - Reset with `await engine.resetCircuitBreaker()`
  - Configure success response
  - Call performSync
  - Verify batch call was made

@Suite("Circuit Breaker - Exponential Backoff")
- Test: "Backoff timing follows exponential progression" (CB-04)
  - Trip circuit breaker first time
  - Verify backoff is ~30s (25-35s range)
  - Reset and trip again
  - Verify backoff is ~60s (55-65s range)
  - Reset and trip again
  - Verify backoff is ~120s (115-125s range)
  - Reset and trip again
  - Verify backoff is ~240s (235-245s range)
  - Reset and trip again
  - Verify backoff is capped at 300s (295-305s range)

**Helper pattern for tripping circuit breaker:**
```swift
private func tripCircuitBreaker(mockNetwork: MockNetworkClient, mockStore: MockDataStore, engine: SyncEngine) async {
    // Health check pass
    mockNetwork.getEventTypesResponses = [.success([APIModelFixture.makeAPIEventType()])]

    // 3 rate limit failures
    mockNetwork.createEventsBatchResponses = [
        .failure(APIError.httpError(429)),
        .failure(APIError.httpError(429)),
        .failure(APIError.httpError(429))
    ]

    // Seed 3 mutations (one per batch to ensure all failures processed)
    for i in 1...3 {
        let request = APIModelFixture.makeCreateEventRequest(id: "evt-\(i)", eventTypeId: "type-1")
        let payload = try! JSONEncoder().encode(request)
        mockStore.seedPendingMutation(entityType: .event, entityId: "evt-\(i)", operation: .create, payload: payload)
    }

    await engine.performSync()
}
```

**Range assertion pattern:**
```swift
let backoff = await engine.circuitBreakerBackoffRemaining
#expect(backoff > 25 && backoff <= 35, "First backoff should be ~30s")
```

**Important:** The exponential backoff test requires tripping the circuit breaker multiple times. Each trip doubles the multiplier:
- Trip 1: 30s * 1.0 = 30s
- Trip 2: 30s * 2.0 = 60s
- Trip 3: 30s * 4.0 = 120s
- Trip 4: 30s * 8.0 = 240s
- Trip 5: 30s * 10.0 = 300s (multiplier capped at 10)
  </action>
  <verify>
File contains @Suite("Circuit Breaker - Sync Blocking") and @Suite("Circuit Breaker - Exponential Backoff").
Tests for CB-03 and CB-04 requirements present.
  </verify>
  <done>
CB-03 (sync blocked) and CB-04 (exponential backoff timing) have dedicated tests.
All 5 circuit breaker requirements (CB-01 through CB-05) have test coverage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run tests and fix any issues</name>
  <files>apps/ios/trendyTests/SyncEngine/CircuitBreakerTests.swift</files>
  <action>
Run the circuit breaker tests to verify they pass.

**Command:**
```bash
cd apps/ios && xcodebuild test \
  -scheme trendy \
  -destination 'platform=iOS Simulator,name=iPhone 16' \
  -only-testing:trendyTests/CircuitBreakerTests \
  2>&1 | grep -E "(Test Case|passed|failed|error:)"
```

**If tests fail:**
1. Read error messages carefully
2. Common issues and fixes:
   - Health check consuming response: Add more success responses to getEventTypesResponses
   - Actor isolation errors: Use `await` for all SyncEngine property access
   - Timing issues: Widen range tolerances (e.g., 20-40s instead of 25-35s)
   - Missing mutations: Ensure seedPendingMutation called before performSync
   - Bootstrap wiping data: Ensure cursor is set to non-zero

**If build fails due to FullDisclosureSDK:**
Note this in summary but don't block - the code compiles and tests are structurally correct.
Document workaround: Tests will run once SDK issue is resolved.

**If tests pass:**
All 5 requirements verified:
- CB-01: ✅ Circuit breaker trips after 3 consecutive rate limit errors
- CB-02: ✅ Circuit breaker resets after backoff period expires
- CB-03: ✅ Sync blocked while circuit breaker tripped
- CB-04: ✅ Exponential backoff timing (30s -> 60s -> 120s -> max 300s)
- CB-05: ✅ Rate limit counter resets on successful sync
  </action>
  <verify>
Either:
1. Tests pass (xcodebuild output shows all tests passed), OR
2. Build issue documented (FullDisclosureSDK) with test code structurally complete
  </verify>
  <done>
Circuit breaker tests either passing or ready to pass once build issue resolved.
All test code complete and follows established patterns.
  </done>
</task>

</tasks>

<verification>
1. CircuitBreakerTests.swift exists in apps/ios/trendyTests/SyncEngine/
2. File contains 5+ @Test functions covering all CB requirements
3. Uses Swift Testing framework (@Test, @Suite, #expect)
4. Uses established mock patterns (MockNetworkClient, MockDataStore, MockDataStoreFactory)
5. No real time delays in tests
6. Fresh SyncEngine instance per test
</verification>

<success_criteria>
All 5 circuit breaker requirements have dedicated test coverage:
- CB-01: Test verifies circuit breaker trips after 3 consecutive rate limit errors
- CB-02: Test verifies circuit breaker resets after backoff period expires
- CB-03: Test verifies sync blocked while circuit breaker tripped
- CB-04: Test verifies exponential backoff timing (30s -> 60s -> 120s -> max 300s)
- CB-05: Test verifies rate limit counter resets on successful sync
</success_criteria>

<output>
After completion, create `.planning/phases/17-unit-tests-circuit-breaker/17-01-SUMMARY.md`
</output>
