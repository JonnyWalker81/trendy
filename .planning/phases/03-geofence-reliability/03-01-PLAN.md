---
phase: 03-geofence-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/ios/trendy/AppDelegate.swift
  - apps/ios/trendy/trendyApp.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "App receives geofence events when launched from terminated state due to location event"
    - "CLLocationManager is initialized immediately when app launches due to .location key"
    - "Pending region events are delivered to delegate after background launch"
  artifacts:
    - path: "apps/ios/trendy/AppDelegate.swift"
      provides: "Background launch handler for location events"
      exports: ["AppDelegate"]
      min_lines: 40
    - path: "apps/ios/trendy/trendyApp.swift"
      provides: "UIApplicationDelegateAdaptor integration"
      contains: "@UIApplicationDelegateAdaptor"
  key_links:
    - from: "apps/ios/trendy/trendyApp.swift"
      to: "apps/ios/trendy/AppDelegate.swift"
      via: "UIApplicationDelegateAdaptor property wrapper"
      pattern: "@UIApplicationDelegateAdaptor.*AppDelegate"
    - from: "apps/ios/trendy/AppDelegate.swift"
      to: "GeofenceManager"
      via: "CLLocationManagerDelegate callbacks forwarding"
      pattern: "didEnterRegion|didExitRegion"
---

<objective>
Add AppDelegate with UIApplicationDelegateAdaptor for handling background location launches.

Purpose: iOS terminates apps but can relaunch them when geofence events occur. SwiftUI's ScenePhase cannot handle didFinishLaunchingWithOptions with the .location key. Without an AppDelegate, the app misses geofence events that occur when terminated.

Output: AppDelegate.swift that handles background launches, integrated into trendyApp.swift via UIApplicationDelegateAdaptor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-geofence-reliability/RESEARCH.md

# Current implementation
@apps/ios/trendy/trendyApp.swift
@apps/ios/trendy/Services/GeofenceManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppDelegate for background location launch</name>
  <files>apps/ios/trendy/AppDelegate.swift</files>
  <action>
Create AppDelegate.swift in the trendy app directory with:

1. Import Foundation, UIKit, CoreLocation
2. Class AppDelegate: NSObject, UIApplicationDelegate, CLLocationManagerDelegate
3. Private property: `locationManager: CLLocationManager?`
4. Implement `application(_:didFinishLaunchingWithOptions:)`:
   - Check if `launchOptions?[.location] != nil`
   - If true, log via `Log.geofence.info("App launched due to location event")`
   - Create CLLocationManager immediately and assign self as delegate
   - This allows pending region events to be delivered after the method returns
5. Implement CLLocationManagerDelegate methods that forward to GeofenceManager:
   - `locationManager(_:didEnterRegion:)` - Log and post notification
   - `locationManager(_:didExitRegion:)` - Log and post notification
   - Use NotificationCenter to forward events since GeofenceManager may not be initialized yet
6. Define notification names: `GeofenceManager.backgroundEntryNotification` and `GeofenceManager.backgroundExitNotification`
7. Use Log.geofence for all logging (matches existing patterns)

Important: The AppDelegate's CLLocationManager is separate from GeofenceManager's. It exists only to receive events during background launch. Events are forwarded via NotificationCenter to be processed by GeofenceManager once the app is fully initialized.

Reference RESEARCH.md "Pattern 1: AppDelegate Integration with SwiftUI" for the implementation pattern.
  </action>
  <verify>
- File exists at apps/ios/trendy/AppDelegate.swift
- Contains `class AppDelegate: NSObject, UIApplicationDelegate, CLLocationManagerDelegate`
- Contains check for `launchOptions?[.location]`
- Contains `Log.geofence.info` calls
- No compiler errors when building
  </verify>
  <done>AppDelegate.swift exists with background location launch handling and CLLocationManagerDelegate implementation</done>
</task>

<task type="auto">
  <name>Task 2: Integrate AppDelegate with trendyApp via UIApplicationDelegateAdaptor</name>
  <files>apps/ios/trendy/trendyApp.swift</files>
  <action>
Modify trendyApp.swift to integrate the AppDelegate:

1. Add `@UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate` property at the top of the struct (after the services section comment)
2. This should be placed before the other properties to ensure it's initialized first during app launch

The UIApplicationDelegateAdaptor property wrapper automatically:
- Creates the AppDelegate instance before SwiftUI scene lifecycle begins
- Calls didFinishLaunchingWithOptions during app launch
- Handles background launches when .location key is present

No other changes needed to trendyApp.swift. The adaptor handles integration automatically.
  </action>
  <verify>
- trendyApp.swift contains `@UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate`
- Project builds without errors
- Adaptor is declared early in the struct (before other @State properties)
  </verify>
  <done>trendyApp.swift integrates AppDelegate via UIApplicationDelegateAdaptor</done>
</task>

<task type="auto">
  <name>Task 3: Add notification observers to GeofenceManager for background events</name>
  <files>apps/ios/trendy/Services/GeofenceManager.swift</files>
  <action>
Enhance GeofenceManager to receive events from AppDelegate's background launch:

1. Add static notification name constants at the top of the class:
   ```swift
   static let backgroundEntryNotification = Notification.Name("GeofenceManager.backgroundEntry")
   static let backgroundExitNotification = Notification.Name("GeofenceManager.backgroundExit")
   ```

2. In init(), add observers for these notifications:
   ```swift
   NotificationCenter.default.addObserver(
       self,
       selector: #selector(handleBackgroundEntry(_:)),
       name: Self.backgroundEntryNotification,
       object: nil
   )
   // Same for exit
   ```

3. Add @objc handler methods:
   ```swift
   @objc private func handleBackgroundEntry(_ notification: Notification) {
       guard let identifier = notification.userInfo?["identifier"] as? String else { return }
       Log.geofence.info("Processing background entry event", context: .with { ctx in
           ctx.add("identifier", identifier)
       })
       // Forward to existing didEnterRegion flow
       // Use the same Task dispatch pattern as the delegate method
   }
   ```

4. In deinit, remove observers:
   ```swift
   NotificationCenter.default.removeObserver(self)
   ```

This allows GeofenceManager to process events that were received by AppDelegate during background launch, once the full app infrastructure is initialized.
  </action>
  <verify>
- GeofenceManager.swift contains static notification name constants
- init() adds notification observers
- deinit removes notification observers
- Handler methods exist and forward to existing event processing
- Project builds without errors
  </verify>
  <done>GeofenceManager receives and processes background launch events via NotificationCenter</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build the iOS app: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -configuration Debug build`
2. Verify no compilation errors
3. Check that AppDelegate.swift is included in the build
4. Verify trendyApp.swift has the UIApplicationDelegateAdaptor
5. Verify GeofenceManager has notification observers

Runtime verification (manual testing):
- Enable a geofence
- Force-quit the app
- Cross the geofence boundary
- Launch the app - should see log entries for background launch handling
</verification>

<success_criteria>
- AppDelegate.swift exists and handles .location launch key
- trendyApp.swift integrates AppDelegate via UIApplicationDelegateAdaptor
- GeofenceManager receives background events via NotificationCenter
- All code compiles without errors
- Structured logging used throughout (Log.geofence.*)
</success_criteria>

<output>
After completion, create `.planning/phases/03-geofence-reliability/03-01-SUMMARY.md`
</output>
