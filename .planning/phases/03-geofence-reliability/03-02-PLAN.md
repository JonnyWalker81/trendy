---
phase: 03-geofence-reliability
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/ios/trendy/Services/GeofenceManager.swift
  - apps/ios/trendy/Views/MainTabView.swift
  - apps/ios/trendy/AppDelegate.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Geofences are re-registered when app becomes active (returns from background)"
    - "Geofences are re-registered when authorization changes to .authorizedAlways"
    - "Geofences are re-registered on app launch (not just MainTabView.onAppear)"
    - "Re-registration is idempotent (safe to call multiple times)"
  artifacts:
    - path: "apps/ios/trendy/Services/GeofenceManager.swift"
      provides: "Lifecycle-aware region re-registration"
      contains: "ensureRegionsRegistered"
    - path: "apps/ios/trendy/AppDelegate.swift"
      provides: "Normal launch re-registration trigger"
      contains: "ensureRegionsRegistered"
  key_links:
    - from: "apps/ios/trendy/AppDelegate.swift"
      to: "apps/ios/trendy/Services/GeofenceManager.swift"
      via: "ensureRegionsRegistered call on normal launch"
      pattern: "ensureRegionsRegistered"
    - from: "apps/ios/trendy/Views/MainTabView.swift"
      to: "apps/ios/trendy/Services/GeofenceManager.swift"
      via: "scenePhase observer calling ensureRegionsRegistered"
      pattern: "scenePhase.*active.*ensureRegionsRegistered"
---

<objective>
Add defensive re-registration at multiple lifecycle points to ensure geofences survive iOS lifecycle events.

Purpose: iOS can drop region monitoring after device restart, iOS eviction, or authorization changes. Re-registering at multiple lifecycle points ensures geofences remain active even after these events.

Output: GeofenceManager with ensureRegionsRegistered() method called at app launch, scene activation, and authorization restoration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-geofence-reliability/RESEARCH.md
@.planning/phases/03-geofence-reliability/03-01-SUMMARY.md

# Current implementation
@apps/ios/trendy/Services/GeofenceManager.swift
@apps/ios/trendy/Views/MainTabView.swift
@apps/ios/trendy/AppDelegate.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ensureRegionsRegistered method to GeofenceManager</name>
  <files>apps/ios/trendy/Services/GeofenceManager.swift</files>
  <action>
Add a new public method `ensureRegionsRegistered()` to GeofenceManager that:

1. Checks authorization status - if not .authorizedAlways, log and return early
2. Fetches active geofences from SwiftData
3. Creates GeofenceDefinition array from active geofences
4. Calls existing `reconcileRegions(desired:)` method
5. Logs the action with context (count of desired regions, current iOS region count)

This method is idempotent - safe to call multiple times. reconcileRegions already handles:
- Adding missing regions
- Removing orphaned regions
- Requesting state for newly added regions

Add the method in the "Geofence Management" section, after reconcileRegions:

```swift
/// Ensures all active geofences are registered with iOS.
/// Safe to call at any lifecycle point - idempotent operation.
/// Call this on: app launch, scene activation, authorization restoration.
func ensureRegionsRegistered() {
    guard hasGeofencingAuthorization else {
        Log.geofence.debug("ensureRegionsRegistered: skipping, no authorization")
        return
    }

    // Fetch active geofences from SwiftData
    let descriptor = FetchDescriptor<Geofence>(
        predicate: #Predicate { $0.isActive }
    )

    guard let geofences = try? modelContext.fetch(descriptor) else {
        Log.geofence.error("ensureRegionsRegistered: failed to fetch geofences")
        return
    }

    // Convert to GeofenceDefinition for reconciliation
    let definitions = geofences.map { geofence in
        GeofenceDefinition(
            identifier: geofence.regionIdentifier,
            name: geofence.name,
            latitude: geofence.latitude,
            longitude: geofence.longitude,
            radius: geofence.radius,
            notifyOnEntry: geofence.notifyOnEntry,
            notifyOnExit: geofence.notifyOnExit
        )
    }

    Log.geofence.info("ensureRegionsRegistered called", context: .with { ctx in
        ctx.add("desired_count", definitions.count)
        ctx.add("current_ios_count", locationManager.monitoredRegions.count)
    })

    reconcileRegions(desired: definitions)
}
```

Also enhance locationManagerDidChangeAuthorization to call ensureRegionsRegistered when authorization is gained or restored (already partially implemented, but make it more robust):

In locationManagerDidChangeAuthorization, replace the existing authorization gain handling with:
```swift
// Handle authorization gain or restoration
if hasGeofencingAuthorization && previousStatus != .authorizedAlways {
    Log.geofence.info("Authorization granted/restored, ensuring regions registered")
    ensureRegionsRegistered()
}
```
  </action>
  <verify>
- GeofenceManager.swift contains `func ensureRegionsRegistered()`
- Method fetches active geofences and calls reconcileRegions
- Method is idempotent (handles edge cases gracefully)
- locationManagerDidChangeAuthorization calls ensureRegionsRegistered on auth gain
- Uses Log.geofence for logging
  </verify>
  <done>GeofenceManager has ensureRegionsRegistered method that can be called at any lifecycle point</done>
</task>

<task type="auto">
  <name>Task 2: Call ensureRegionsRegistered on normal app launch</name>
  <files>apps/ios/trendy/AppDelegate.swift</files>
  <action>
Enhance AppDelegate to trigger region re-registration on normal (non-background) app launches:

1. Add a method to post a notification for normal launch registration:
   ```swift
   static let normalLaunchNotification = Notification.Name("GeofenceManager.normalLaunch")
   ```

2. In didFinishLaunchingWithOptions, AFTER the .location check block, add:
   ```swift
   // For all launches (background or normal), notify GeofenceManager to ensure regions
   // This handles device restart, iOS eviction, and normal app launch scenarios
   NotificationCenter.default.post(name: Self.normalLaunchNotification, object: nil)
   Log.geofence.info("Posted normal launch notification for region re-registration")
   ```

3. In GeofenceManager init(), add observer for this notification:
   ```swift
   NotificationCenter.default.addObserver(
       self,
       selector: #selector(handleNormalLaunch(_:)),
       name: AppDelegate.normalLaunchNotification,
       object: nil
   )
   ```

4. Add handler in GeofenceManager:
   ```swift
   @objc private func handleNormalLaunch(_ notification: Notification) {
       Log.geofence.info("Handling normal launch notification")
       ensureRegionsRegistered()
   }
   ```

This ensures regions are re-registered after:
- Device restart (iOS drops regions, app relaunches)
- iOS eviction (system killed app, user relaunches)
- App updates
- Normal user launch
  </action>
  <verify>
- AppDelegate.swift has normalLaunchNotification constant
- didFinishLaunchingWithOptions posts notification after .location check
- GeofenceManager observes and handles the notification
- ensureRegionsRegistered is called on normal launch
  </verify>
  <done>App launch triggers geofence re-registration via notification</done>
</task>

<task type="auto">
  <name>Task 3: Call ensureRegionsRegistered when app becomes active</name>
  <files>apps/ios/trendy/Views/MainTabView.swift</files>
  <action>
Add scenePhase observer to MainTabView that calls ensureRegionsRegistered when app becomes active.

1. Add @Environment(\.scenePhase) var scenePhase to MainTabView
2. Add .onChange(of: scenePhase) modifier to the main content
3. When scenePhase changes to .active, call geofenceManager.ensureRegionsRegistered()

This handles the scenario where:
- User backgrounds the app
- iOS potentially drops regions under memory pressure
- User returns to the app
- Regions are re-registered

Implementation:
```swift
@Environment(\.scenePhase) private var scenePhase

// In body, add modifier:
.onChange(of: scenePhase) { oldPhase, newPhase in
    if newPhase == .active {
        Log.geofence.debug("Scene became active, ensuring regions registered")
        geofenceManager?.ensureRegionsRegistered()
    }
}
```

Note: This is in addition to any existing onAppear logic. The scenePhase observer handles returns from background, while onAppear handles initial tab appearance.

Check if MainTabView already has a geofenceManager environment property. If not, add:
```swift
@Environment(GeofenceManager.self) private var geofenceManager: GeofenceManager?
```
  </action>
  <verify>
- MainTabView.swift has scenePhase environment property
- .onChange(of: scenePhase) modifier exists
- Calls ensureRegionsRegistered when scene becomes active
- Uses Log.geofence for logging
  </verify>
  <done>Scene activation triggers geofence re-registration</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build the iOS app: `cd apps/ios && xcodebuild -scheme "Trendy (Local)" -configuration Debug build`
2. Verify no compilation errors
3. Check GeofenceManager has ensureRegionsRegistered method
4. Check AppDelegate posts normalLaunchNotification
5. Check MainTabView observes scenePhase

Manual testing flow:
1. Create and enable a geofence
2. Verify it appears in Geofence Debug view as registered
3. Background the app for 30+ seconds
4. Return to app - should see "Scene became active" log
5. Force quit and relaunch - should see "normal launch notification" log
6. Check Geofence Debug view - regions should still be registered
</verification>

<success_criteria>
- ensureRegionsRegistered() method exists and is idempotent
- Method is called on: app launch, scene activation, authorization restoration
- All lifecycle triggers use Log.geofence for logging
- Geofences survive app backgrounding and relaunching
- Geofences survive force quit and relaunch
</success_criteria>

<output>
After completion, create `.planning/phases/03-geofence-reliability/03-02-SUMMARY.md`
</output>
