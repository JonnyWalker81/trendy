# frozen_string_literal: true

# Fastfile - define build lanes
# For more information: https://docs.fastlane.tools

default_platform(:ios)

# Constants
PROJECT_PATH = "trendy.xcodeproj"
MAIN_TARGET = "trendy"

platform :ios do
  before_all do
    setup_ci if ENV["CI"]
  end

  desc "Run tests"
  lane :test do
    run_tests(
      project: PROJECT_PATH,
      scheme: "trendy",
      devices: ["iPhone 15"],
      clean: true,
      code_coverage: true,
      result_bundle: true
    )
  end

  desc "Build for development (local debugging)"
  lane :build_debug do
    build_app(
      project: PROJECT_PATH,
      scheme: "trendy (local)",
      configuration: "Debug",
      skip_archive: true,
      skip_codesigning: true
    )
  end

  desc "Deploy staging build for internal testing"
  lane :staging do
    # Calculate new build number
    new_build_number = latest_testflight_build_number + 1

    # Set build number directly in Info.plist (avoids agvtool dependency)
    set_info_plist_value(
      path: "trendy/trendy-Info.plist",
      key: "CFBundleVersion",
      value: new_build_number.to_s
    )

    # Build the app
    build_app(
      project: PROJECT_PATH,
      scheme: "trendy (staging)",
      configuration: "Staging",
      export_method: "app-store"
    )

    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
  end

  desc "Deploy beta build to TestFlight"
  lane :beta do
    # Ensure we're on a clean git state
    ensure_git_status_clean unless ENV["SKIP_GIT_CHECK"]

    # Calculate new build number
    new_build_number = latest_testflight_build_number + 1

    # Set build number directly in Info.plist (avoids agvtool dependency)
    set_info_plist_value(
      path: "trendy/trendy-Info.plist",
      key: "CFBundleVersion",
      value: new_build_number.to_s
    )

    # Sync widget extension version with main app (update project build settings, not Info.plist)
    # Widget uses GENERATE_INFOPLIST_FILE = YES, so it reads version from build settings
    project = Xcodeproj::Project.open("../#{PROJECT_PATH}")
    widget_target = project.targets.find { |t| t.name == "TrendyWidgetsExtension" }
    if widget_target
      widget_target.build_configurations.each do |config|
        config.build_settings["CURRENT_PROJECT_VERSION"] = new_build_number.to_s
        config.build_settings["MARKETING_VERSION"] = get_info_plist_value(path: "trendy/trendy-Info.plist", key: "CFBundleShortVersionString")
      end
      project.save
      UI.success("Updated widget extension version to #{new_build_number}")
    else
      UI.error("Could not find TrendyWidgetsExtension target")
    end

    # Build the app
    build_app(
      project: PROJECT_PATH,
      scheme: "trendy (TestFlight)",
      configuration: "TestFlight",
      export_method: "app-store"
    )

    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: false,
      distribute_external: false,
      changelog: changelog_from_git_commits(
        commits_count: 10,
        pretty: "- %s"
      )
    )

    # Commit version bump
    git_commit(
      path: ["trendy/trendy-Info.plist", "trendy.xcodeproj/project.pbxproj"],
      message: "chore: bump build number to #{new_build_number} for TestFlight"
    )

    # Tag release
    version = get_info_plist_value(path: "trendy/trendy-Info.plist", key: "CFBundleShortVersionString")
    add_git_tag(tag: "testflight/#{version}-#{new_build_number}")
  end

  desc "Deploy to App Store"
  lane :release do
    # Ensure we're on main branch
    ensure_git_branch(branch: "main")
    ensure_git_status_clean

    # Get version bump type from environment or prompt
    version_bump_type = ENV["VERSION_BUMP"] || UI.select(
      "Select version bump type:",
      ["patch", "minor", "major"]
    )

    # Get current version from Info.plist
    current_version = get_info_plist_value(
      path: "trendy/trendy-Info.plist",
      key: "CFBundleShortVersionString"
    )

    # Calculate new version
    version_parts = current_version.split(".").map(&:to_i)
    case version_bump_type
    when "major"
      version_parts[0] += 1
      version_parts[1] = 0
      version_parts[2] = 0
    when "minor"
      version_parts[1] += 1
      version_parts[2] = 0
    when "patch"
      version_parts[2] = (version_parts[2] || 0) + 1
    end
    new_version = version_parts.join(".")

    # Set new version in Info.plist
    set_info_plist_value(
      path: "trendy/trendy-Info.plist",
      key: "CFBundleShortVersionString",
      value: new_version
    )

    # Reset build number for new version
    set_info_plist_value(
      path: "trendy/trendy-Info.plist",
      key: "CFBundleVersion",
      value: "1"
    )

    # Build the app
    build_app(
      project: PROJECT_PATH,
      scheme: "trendy (production)",
      configuration: "Release",
      export_method: "app-store"
    )

    # Upload to App Store Connect
    upload_to_app_store(
      skip_screenshots: true,
      skip_metadata: false,
      submit_for_review: false,  # Set to true for auto-submit
      automatic_release: false,
      precheck_include_in_app_purchases: false
    )

    # Commit and tag
    git_commit(
      path: "trendy/trendy-Info.plist",
      message: "chore: release v#{new_version}"
    )

    add_git_tag(tag: "v#{new_version}")

    push_to_git_remote(tags: true)
  end

  desc "Sync code signing certificates and profiles using match"
  lane :sync_certs do
    match(
      type: "development",
      app_identifier: [
        "com.memento.trendy",
        "com.memento.trendy.staging",
        "com.memento.trendy.testflight"
      ],
      readonly: running_on_ci
    )

    match(
      type: "appstore",
      app_identifier: [
        "com.memento.trendy",
        "com.memento.trendy.staging",
        "com.memento.trendy.testflight"
      ],
      readonly: running_on_ci
    )
  end

  desc "Register new devices from a file"
  lane :register_devices_from_file do
    register_devices(devices_file: "./fastlane/devices.txt")
    match(type: "development", force_for_new_devices: true)
  end

  desc "Take screenshots for App Store (raw, unframed)"
  lane :screenshots_raw do
    # Clear existing screenshots
    sh("rm -rf ./screenshots/raw/*") if Dir.exist?("./screenshots/raw")

    capture_screenshots(
      project: PROJECT_PATH,
      scheme: "trendy (local)",
      output_directory: "./screenshots/raw",
      clear_previous_screenshots: true,
      devices: [
        "iPhone 16 Pro Max"        # 6.9" display (1320x2868) - required for App Store
      ],
      languages: ["en-US"],
      override_status_bar: true,
      concurrent_simulators: true,
      stop_after_first_error: false,
      launch_arguments: [
        "-FASTLANE_SNAPSHOT",
        "--screenshot-mode"
      ],
      test_target_name: "trendyUITests",
      only_testing: ["trendyUITests/ScreenshotTests"]
    )

    UI.success("ðŸ“¸ Raw screenshots captured in ./screenshots/raw/")
  end

  desc "Take screenshots and add device frames with marketing text"
  lane :screenshots do
    # First capture raw screenshots
    screenshots_raw

    # Copy raw screenshots to framed directory before framing
    sh("mkdir -p ./screenshots/framed")
    sh("cp -R ./screenshots/raw/* ./screenshots/framed/")

    # Then add device frames and marketing text (works in-place)
    frame_screenshots(
      path: "./screenshots/framed"
    )

    # Open the output folder
    sh("open ./screenshots/framed") if File.directory?("./screenshots/framed")

    UI.success("ðŸ–¼ï¸ Framed screenshots ready in ./screenshots/framed/")
  end

  desc "Frame existing screenshots (skip capture)"
  lane :frame_screenshots_only do
    sh("mkdir -p ./screenshots/framed")
    sh("cp -R ./screenshots/raw/* ./screenshots/framed/")

    frame_screenshots(
      path: "./screenshots/framed"
    )

    sh("open ./screenshots/framed") if File.directory?("./screenshots/framed")
  end

  # Private helper lanes
  private_lane :running_on_ci do
    ENV["CI"] == "true"
  end

  error do |lane, exception|
    # Notify on failure (customize as needed)
    UI.error("Lane #{lane} failed with: #{exception.message}")

    # Clean up on error
    clean_build_artifacts

    # Could add Slack/Discord notification here
    # slack(
    #   message: "Fastlane #{lane} failed!",
    #   success: false,
    #   payload: { "Error" => exception.message }
    # )
  end
end
